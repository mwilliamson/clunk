sealed interface HtmlNode {
}

record HtmlAttribute(name: String, value: String)

fun element(tagName: String, attributes: List[HtmlAttribute], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag([tagName], attributes, false, "");
    return HtmlElement(tag, children);
}

record HtmlElement(tag: HtmlTag, children: List[HtmlNode]) <: HtmlNode {
    property defaultTagName: String {
        return tag.defaultTagName;
    }
}

record HtmlForceWrite() <: HtmlNode

record HtmlTag(
    tagNames: List[String],
    attributes: List[HtmlAttribute],
    isCollapsible: Bool,
    separator: String,
) {
    property defaultTagName: String {
        return tagNames[0];
    }

    property isVoid: Bool {
        return defaultTagName == "br" ||
            defaultTagName == "hr" ||
            defaultTagName == "img";
    }
}

fun text(value: String) -> HtmlText {
    return HtmlText(value);
}

record HtmlText(value: String) <: HtmlNode {
    property isEmpty: Bool {
        return value == "";
    }
}

fun stripEmpty(nodes: List[HtmlNode]) -> List[HtmlNode] {
    return nodes.flatMap(stripEmptyNode);
}

fun stripEmptyNode(node: HtmlNode) -> List[HtmlNode] {
    switch (node) {
        case HtmlElement element {
            return [element];
        }

        case HtmlForceWrite forceWrite {
            return [forceWrite];
        }

        case HtmlText text {
            if (text.isEmpty) {
                return [];
            } else {
                return [text];
            }
        }
    }
}
