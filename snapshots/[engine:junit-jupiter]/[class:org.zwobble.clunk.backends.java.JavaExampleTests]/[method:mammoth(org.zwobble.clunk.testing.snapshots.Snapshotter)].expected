Source path: src/mammoth/documents.clunk
sealed interface DocumentElement {
}

interface HasChildren {
}

record Bookmark(name: String) <: DocumentElement

record BreakLine() <: DocumentElement

record BreakPage() <: DocumentElement

record BreakColumn() <: DocumentElement

record Comment(
    commentId: String,
    body: List[DocumentElement],
    authorName: Option[String],
    authorInitials: Option[String],
)

record CommentReference(commentId: String) <: DocumentElement

record Document(
    children: List[DocumentElement],
    notes: List[Note],
    comments: List[Comment],
) <: HasChildren

record Hyperlink(
    href: String,
    targetFrame: Option[String],
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record Image(
    altText: Option[String],
    contentType: Option[String],
) <: DocumentElement

record Note(
    noteType: NoteType,
    id: String,
    body: List[DocumentElement],
)

enum NoteType {
    FOOTNOTE,
    ENDNOTE,
}

record NoteReference(
    noteType: NoteType,
    noteId: String,
) <: DocumentElement

record NumberingLevel(
    levelIndex: String,
    isOrdered: Bool,
)

record NumberingStyle(
    numId: String,
)

record Paragraph(
    style: Option[String],
    numbering: Option[NumberingLevel],
    indent: ParagraphIndent,
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record ParagraphIndent(
    start: Option[String],
    end: Option[String],
    firstLine: Option[String],
    hanging: Option[String],
)

record Run(
    isBold: Bool,
    isItalic: Bool,
    isUnderline: Bool,
    isStrikethrough: Bool,
    isAllCaps: Bool,
    isSmallCaps: Bool,
    verticalAlignment: VerticalAlignment,
    style: Option[String],
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record Style(
    styleId: String,
    name: Option[String],
)

record Tab() <: DocumentElement

record Table(
    style: Option[Style],
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record TableCell(
    rowspan: Int,
    colspan: Int,
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record TableRow(
    children: List[DocumentElement],
    isHeader: Bool,
) <: DocumentElement, HasChildren

record Text(
    value: String,
) <: DocumentElement

enum VerticalAlignment {
    SUPERSCRIPT,
    SUBSCRIPT,
    BASELINE
}


==============

Source path: src/mammoth/docx/styles.clunk
import mammoth/xml.XmlElement;
import mammoth/xml.XmlElementList;

// TODO: deal with naming conflict with namespace class Styles
record DocumentStyles(paragraphStyles: Map[String, Style]) {
    fun findParagraphStyleById(name: String) -> Option[Style] {
        return none();
    }
}

record Style(styleId: String, name: Option[String])

fun readStylesXmlElement(element: XmlElement) -> DocumentStyles {
    var styleElements = element.findChildren("w:style");
    return DocumentStyles(readStyles(styleElements, "paragraph"));
}

fun readStyles(styleElements: XmlElementList, styleType: String) -> Map[String, Style] {
    return #[];
}


==============

Source path: src/mammoth/docx/styles.test.clunk
import stdlib/assertions.assertThat;
import stdlib/matchers.equalTo;
import stdlib/matchers.hasMember;
import stdlib/matchers.isNone;
import stdlib/matchers.isSome;
import mammoth/docx/styles.readStylesXmlElement;
import mammoth/docx/styles.Style;
import mammoth/xml;

test "paragraph style is none if no style with that ID exists" {
    var element = xml.element("w:styles", #[], []);

    var styles = readStylesXmlElement(element);

    assertThat(styles.findParagraphStyleById("Heading1"), isNone());
}

test "paragraph style can be found by ID" {
    var element = xml.element("w:styles", #[], [
        xml.element("w:style", #[["w:type", "paragraph"], ["w:styleId", "Heading1"]], [
            xml.element("w:name", #[["w:val", "Heading 1"]], []),
        ]),
    ]);

    var styles = readStylesXmlElement(element);

    assertThat(
        styles.findParagraphStyleById("Heading1"),
        isSome(hasMember(Style::name, isSome(equalTo("Heading 1")))),
    );
}


==============

Source path: src/mammoth/html.clunk
sealed interface HtmlNode {
}

fun element(tagNames: List[String], attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    return freshElement(tagNames, attributes, children);
}

fun collapsibleElement(tagNames: List[String], attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, true, "");
    return HtmlElement(tag, children);
}

fun freshElement(tagNames: List[String], attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, false, "");
    return HtmlElement(tag, children);
}

fun collapsibleElementWithSeparator(
    tagNames: List[String],
    attributes: Map[String, String],
    children: List[HtmlNode],
    separator: String,
) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, true, separator);
    return HtmlElement(tag, children);
}

fun freshElementWithSeparator(
    tagNames: List[String],
    attributes: Map[String, String],
    children: List[HtmlNode],
    separator: String,
) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, false, separator);
    return HtmlElement(tag, children);
}

record HtmlElement(tag: HtmlTag, children: List[HtmlNode]) <: HtmlNode {
    property attributes: Map[String, String] {
        return tag.attributes;
    }

    property defaultTagName: String {
        return tag.defaultTagName;
    }

    property tagNames: List[String] {
        return tag.tagNames;
    }

    property isCollapsible: Bool {
        return tag.isCollapsible;
    }

    property isVoid: Bool {
        return tag.isVoid;
    }

    property separator: String {
        return tag.separator;
    }
}

fun forceWrite() -> HtmlForceWrite {
    // TODO: support top-level variables
    return HtmlForceWrite();
}

record HtmlForceWrite() <: HtmlNode

record HtmlTag(
    tagNames: List[String],
    attributes: Map[String, String],
    isCollapsible: Bool,
    separator: String,
) {
    property defaultTagName: String {
        return tagNames.get(0);
    }

    property isVoid: Bool {
        return defaultTagName == "br" ||
            defaultTagName == "hr" ||
            defaultTagName == "img";
    }
}

fun text(value: String) -> HtmlText {
    return HtmlText(value);
}

record HtmlText(value: String) <: HtmlNode {
    property isEmpty: Bool {
        return value == "";
    }
}

fun stripEmpty(nodes: List[HtmlNode]) -> List[HtmlNode] {
    return [
        for node in nodes
        for child in stripEmptyNode(node)
        yield child
    ];
}

fun stripEmptyNode(node: HtmlNode) -> List[HtmlNode] {
    switch (node) {
        case HtmlElement {
            var children = stripEmpty(node.children);
            if (!node.isVoid && children.length() == 0) {
                return [];
            } else {
                return [HtmlElement(node.tag, children)];
            }
        }

        case HtmlForceWrite {
            return [node];
        }

        case HtmlText {
            if (node.isEmpty) {
                return [];
            } else {
                return [node];
            }
        }
    }
}

fun collapse(nodes: List[HtmlNode]) -> List[HtmlNode] {
    var collapsed = MutableList[HtmlNode]();

    for (var node in nodes) {
        collapsingAdd(collapsed, node);
    }

    return collapsed;
}

fun collapsingAdd(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Unit {
    var collapsedNode = collapseNode(node);
    if (!tryCollapse(collapsed, collapsedNode)) {
        collapsed.add(collapsedNode);
    }
}

fun collapseNode(node: HtmlNode) -> HtmlNode {
    switch (node) {
        case HtmlElement {
            return HtmlElement(
                node.tag,
                collapse(node.children),
            );
        }

        case HtmlForceWrite {
            return node;
        }

        case HtmlText {
            return node;
        }
    }
}

fun tryCollapse(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Bool {
    if (collapsed.length() == 0) {
        return false;
    }

    var last = collapsed.last();

    if (!(node instanceof HtmlElement)) {
        return false;
    }

    if (!(last instanceof HtmlElement)) {
        return false;
    }

    if (!node.isCollapsible || !(node.tagNames.contains(last.defaultTagName) && node.attributes == last.attributes)) {
        return false;
    }

    if (node.separator != "") {
        (last.children as MutableList[HtmlNode]).add(text(node.separator));
    }

    for (var child in node.children) {
        collapsingAdd(last.children as MutableList[HtmlNode], child);
    }

    return true;
}


==============

Source path: src/mammoth/html.test.clunk
import stdlib/assertions.assertThat;
import stdlib/matchers.equalTo;
import mammoth/html;

testSuite "stripEmpty" {
    test "text nodes with text are not stripped" {
        var nodes = [html.text("H")];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.text("H")]));
    }

    test "empty text nodes are stripped" {
        var nodes = [html.text("")];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "elements with non-empty children are not stripped" {
        var nodes = [html.element(["p"], #[], [html.text("H")])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.element(["p"], #[], [html.text("H")])]));
    }

    test "elements with no children are stripped" {
        var nodes = [html.element(["p"], #[], [])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "elements with only empty children are stripped" {
        var nodes = [html.element(["p"], #[], [html.text("")])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "empty children are removed" {
        var nodes = [
            html.element(["ul"], #[], [
                html.element(["li"], #[], [html.text("")]),
                html.element(["li"], #[], [html.text("H")]),
            ]),
        ];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([
            html.element(["ul"], #[], [
                html.element(["li"], #[], [html.text("H")]),
            ]),
        ]));
    }

    test "self-closing elements are never empty" {
        var nodes = [html.element(["br"], #[], [])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.element(["br"], #[], [])]));
    }

    test "force writes are never empty" {
        var nodes = [html.forceWrite()];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.forceWrite()]));
    }
}

testSuite "collapse" {
    test "collapsing does nothing to single text node" {
        var nodes = [html.text("Bluebells")];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([html.text("Bluebells")]));
    }

    test "consecutive fresh elements are not collapsed" {
        var nodes = [
            html.freshElement(["p"], #[], []),
            html.freshElement(["p"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["p"], #[], []),
            html.freshElement(["p"], #[], []),
        ]));
    }

    test "elements with different tag names are not collapsed" {
        var nodes = [
            html.collapsibleElement(["p"], #[], [html.text("One")]),
            html.collapsibleElement(["div"], #[], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[], [html.text("One")]),
            html.collapsibleElement(["div"], #[], [html.text("Two")]),
        ]));
    }

    test "elements with different attributes are not collapsed" {
        var nodes = [
            html.collapsibleElement(["p"], #[["id", "a"]], [html.text("One")]),
            html.collapsibleElement(["p"], #[], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[["id", "a"]], [html.text("One")]),
            html.collapsibleElement(["p"], #[], [html.text("Two")]),
        ]));
    }

    test "consecutive collapsible elements are collapsed if they have the same tag name and no attributes" {
        var nodes = [
            html.collapsibleElement(["p"], #[], [html.text("One")]),
            html.collapsibleElement(["p"], #[], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[], [html.text("One"), html.text("Two")]),
        ]));
    }

    test "consecutive collapsible elements are collapsed if they have the same tag name and same attributes" {
        var nodes = [
            html.collapsibleElement(["p"], #[["a", "1"], ["b", "2"]], [html.text("One")]),
            html.collapsibleElement(["p"], #[["b", "2"], ["a", "1"]], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[["a", "1"], ["b", "2"]], [html.text("One"), html.text("Two")]),
        ]));
    }

    test "children of elements are collapsed" {
        var nodes = [
            html.freshElement(["div"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One")]),
                html.collapsibleElement(["p"], #[], [html.text("Two")]),
            ]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["div"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One"), html.text("Two")]),
            ]),
        ]));
    }

    test "children of collapsed element can collapse with children of previous element" {
        var nodes = [
            html.collapsibleElement(["blockquote"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One")]),
            ]),
            html.collapsibleElement(["blockquote"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("Two")]),
            ]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["blockquote"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One"), html.text("Two")]),
            ]),
        ]));
    }

    test "collapsible element can collapse into previous fresh element" {
        var nodes = [
            html.freshElement(["p"], #[], []),
            html.collapsibleElement(["p"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["p"], #[], []),
        ]));
    }

    test "consecutive elements can collapse if second element has choice of tag names including main tag name of first element" {
        var nodes = [
            html.collapsibleElement(["ol"], #[], []),
            html.collapsibleElement(["ul", "ol"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["ol"], #[], []),
        ]));
    }

    test "consecutive elements cannot collapse if second element has tag name as non-main tag name of first element" {
        var nodes = [
            html.collapsibleElement(["ul", "ol"], #[], []),
            html.collapsibleElement(["ol"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["ul", "ol"], #[], []),
            html.collapsibleElement(["ol"], #[], []),
        ]));
    }

    test "when separator is present then separator is prepended to collapsed element" {
        var nodes = [
            html.freshElement(["pre"], #[], [html.text("Hello")]),
            html.collapsibleElementWithSeparator(
                ["pre"],
                #[],
                [html.text(" the"), html.text("re")],
                "\n"
            ),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["pre"], #[], [
                html.text("Hello"),
                html.text("\n"),
                html.text(" the"),
                html.text("re"),
            ]),
        ]));
    }
}


==============

Source path: src/mammoth/xml.clunk
sealed interface XmlNode {
}

fun element(
    name: String,
    attributes: Map[String, String],
    children: List[XmlNode],
) -> XmlElement {
    return XmlElement(name, attributes, children);
}

record XmlElement(
    name: String,
    attributes: Map[String, String],
    children: List[XmlNode],
) <: XmlNode {
    fun findChildren(name: String) -> XmlElementList {
        return XmlElementList([
            for child in children
            if child instanceof XmlElement
            if child.name == name
            yield child
        ]);
    }

    fun getAttribute(name: String) -> Option[String] {
        return attributes.get(name);
    }
}

record XmlElementList(
    elements: List[XmlElement],
)

record XmlTextNode(
    value: String,
) <: XmlNode


==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/DocumentElement.java
package org.zwobble.mammoth.internal.mammoth.documents;

public sealed interface DocumentElement permits Bookmark, BreakLine, BreakPage, BreakColumn, CommentReference, Hyperlink, Image, NoteReference, Paragraph, Run, Tab, Table, TableCell, TableRow, Text {
    <T> T accept(Visitor<T> visitor);
    public interface Visitor<T> {
        T visit(Bookmark bookmark);
        T visit(BreakLine breakLine);
        T visit(BreakPage breakPage);
        T visit(BreakColumn breakColumn);
        T visit(CommentReference commentReference);
        T visit(Hyperlink hyperlink);
        T visit(Image image);
        T visit(NoteReference noteReference);
        T visit(Paragraph paragraph);
        T visit(Run run);
        T visit(Tab tab);
        T visit(Table table);
        T visit(TableCell tableCell);
        T visit(TableRow tableRow);
        T visit(Text text);
    }
}


==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/HasChildren.java
package org.zwobble.mammoth.internal.mammoth.documents;

public interface HasChildren {
}


==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Bookmark.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Bookmark(String name) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/BreakLine.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record BreakLine() implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/BreakPage.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record BreakPage() implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/BreakColumn.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record BreakColumn() implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Comment.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Comment(String commentId, java.util.List<? extends DocumentElement> body, java.util.Optional<String> authorName, java.util.Optional<String> authorInitials) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/CommentReference.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record CommentReference(String commentId) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Document.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Document(java.util.List<? extends DocumentElement> children, java.util.List<Note> notes, java.util.List<Comment> comments) implements org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Hyperlink.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Hyperlink(String href, java.util.Optional<String> targetFrame, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Image.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Image(java.util.Optional<String> altText, java.util.Optional<String> contentType) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Note.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Note(NoteType noteType, String id, java.util.List<? extends DocumentElement> body) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/NoteType.java
package org.zwobble.mammoth.internal.mammoth.documents;

public enum NoteType {
    FOOTNOTE,
    ENDNOTE
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/NoteReference.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record NoteReference(NoteType noteType, String noteId) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/NumberingLevel.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record NumberingLevel(String levelIndex, boolean isOrdered) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/NumberingStyle.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record NumberingStyle(String numId) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Paragraph.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Paragraph(java.util.Optional<String> style, java.util.Optional<NumberingLevel> numbering, ParagraphIndent indent, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/ParagraphIndent.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record ParagraphIndent(java.util.Optional<String> start, java.util.Optional<String> end, java.util.Optional<String> firstLine, java.util.Optional<String> hanging) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Run.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Run(boolean isBold, boolean isItalic, boolean isUnderline, boolean isStrikethrough, boolean isAllCaps, boolean isSmallCaps, VerticalAlignment verticalAlignment, java.util.Optional<String> style, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Style.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Style(String styleId, java.util.Optional<String> name) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Tab.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Tab() implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Table.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Table(java.util.Optional<Style> style, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/TableCell.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record TableCell(int rowspan, int colspan, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/TableRow.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record TableRow(java.util.List<? extends DocumentElement> children, boolean isHeader) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Text.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Text(String value) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/VerticalAlignment.java
package org.zwobble.mammoth.internal.mammoth.documents;

public enum VerticalAlignment {
    SUPERSCRIPT,
    SUBSCRIPT,
    BASELINE
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/XmlNode.java
package org.zwobble.mammoth.internal.mammoth.xml;

public sealed interface XmlNode permits XmlElement, XmlTextNode {
    <T> T accept(Visitor<T> visitor);
    public interface Visitor<T> {
        T visit(XmlElement xmlElement);
        T visit(XmlTextNode xmlTextNode);
    }
}


==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/XmlElement.java
package org.zwobble.mammoth.internal.mammoth.xml;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElementList;

public record XmlElement(String name, java.util.Map<String, String> attributes, java.util.List<? extends XmlNode> children) implements org.zwobble.mammoth.internal.mammoth.xml.XmlNode {
    public XmlElementList findChildren(String name) {
        return new XmlElementList(children().stream().flatMap((child) -> child instanceof XmlElement ? java.util.stream.Stream.of((org.zwobble.mammoth.internal.mammoth.xml.XmlElement) child) : null).filter((child) -> child.name().equals(name)).toList());
    }

    public java.util.Optional<String> getAttribute(String name) {
        return java.util.Optional.ofNullable(attributes().get(name));
    }
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.xml.XmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/XmlElementList.java
package org.zwobble.mammoth.internal.mammoth.xml;

public record XmlElementList(java.util.List<XmlElement> elements) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/XmlTextNode.java
package org.zwobble.mammoth.internal.mammoth.xml;

public record XmlTextNode(String value) implements org.zwobble.mammoth.internal.mammoth.xml.XmlNode {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.xml.XmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/Xml.java
package org.zwobble.mammoth.internal.mammoth.xml;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElement;

public class Xml {
    public static XmlElement element(String name, java.util.Map<String, String> attributes, java.util.List<? extends XmlNode> children) {
        return new XmlElement(name, attributes, children);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/docx/styles/DocumentStyles.java
package org.zwobble.mammoth.internal.mammoth.docx.styles;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElement;
import org.zwobble.mammoth.internal.mammoth.xml.XmlElementList;
import java.util.Optional;

public record DocumentStyles(java.util.Map<String, Style> paragraphStyles) {
    public java.util.Optional<Style> findParagraphStyleById(String name) {
        return Optional.empty();
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/docx/styles/Style.java
package org.zwobble.mammoth.internal.mammoth.docx.styles;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElement;
import org.zwobble.mammoth.internal.mammoth.xml.XmlElementList;

public record Style(String styleId, java.util.Optional<String> name) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/docx/styles/Styles.java
package org.zwobble.mammoth.internal.mammoth.docx.styles;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElement;
import org.zwobble.mammoth.internal.mammoth.xml.XmlElementList;
import org.zwobble.mammoth.internal.mammoth.docx.styles.DocumentStyles;

public class Styles {
    public static DocumentStyles readStylesXmlElement(XmlElement element) {
        var styleElements = element.findChildren("w:style");
        return new DocumentStyles(readStyles(styleElements, "paragraph"));
    }
    public static java.util.Map<String, Style> readStyles(XmlElementList styleElements, String styleType) {
        return java.util.Map.ofEntries();
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/docx/styles/StylesTests.java
package org.zwobble.mammoth.internal.mammoth.docx.styles;

import static org.zwobble.mammoth.internal.mammoth.docx.styles.Styles.readStylesXmlElement;
import org.zwobble.mammoth.internal.mammoth.docx.styles.Style;
import org.zwobble.mammoth.internal.mammoth.xml.Xml;
import static org.zwobble.precisely.Matchers.equalTo;
import java.util.Optional;
import static org.zwobble.precisely.AssertThat.assertThat;
import static org.zwobble.precisely.Matchers.isOptionalOf;
import static org.zwobble.precisely.Matchers.has;

public class StylesTests {
    @org.junit.jupiter.api.Test
    @org.junit.jupiter.api.DisplayName("paragraph style is none if no style with that ID exists")
    public void paragraphStyleIsNoneIfNoStyleWithThatIDExists() {
        var element = Xml.element("w:styles", java.util.Map.ofEntries(), java.util.List.of());

        var styles = readStylesXmlElement(element);

        assertThat(styles.findParagraphStyleById("Heading1"), equalTo(Optional.empty()));
    }
    @org.junit.jupiter.api.Test
    @org.junit.jupiter.api.DisplayName("paragraph style can be found by ID")
    public void paragraphStyleCanBeFoundByID() {
        var element = Xml.element("w:styles", java.util.Map.ofEntries(), java.util.List.of(Xml.element("w:style", java.util.Map.ofEntries(java.util.Map.entry("w:type", "paragraph"), java.util.Map.entry("w:styleId", "Heading1")), java.util.List.of(Xml.element("w:name", java.util.Map.ofEntries(java.util.Map.entry("w:val", "Heading 1")), java.util.List.of())))));

        var styles = readStylesXmlElement(element);

        assertThat(styles.findParagraphStyleById("Heading1"), isOptionalOf(has("name", org.zwobble.mammoth.internal.mammoth.docx.styles.Style::name, isOptionalOf(equalTo("Heading 1")))));
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlNode.java
package org.zwobble.mammoth.internal.mammoth.html;

public sealed interface HtmlNode permits HtmlElement, HtmlForceWrite, HtmlText {
    <T> T accept(Visitor<T> visitor);
    public interface Visitor<T> {
        T visit(HtmlElement htmlElement);
        T visit(HtmlForceWrite htmlForceWrite);
        T visit(HtmlText htmlText);
    }
}


==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlElement.java
package org.zwobble.mammoth.internal.mammoth.html;

public record HtmlElement(HtmlTag tag, java.util.List<? extends HtmlNode> children) implements org.zwobble.mammoth.internal.mammoth.html.HtmlNode {
    public java.util.Map<String, String> attributes() {
        return tag().attributes();
    }

    public String defaultTagName() {
        return tag().defaultTagName();
    }

    public java.util.List<String> tagNames() {
        return tag().tagNames();
    }

    public boolean isCollapsible() {
        return tag().isCollapsible();
    }

    public boolean isVoid() {
        return tag().isVoid();
    }

    public String separator() {
        return tag().separator();
    }
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.html.HtmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlForceWrite.java
package org.zwobble.mammoth.internal.mammoth.html;

public record HtmlForceWrite() implements org.zwobble.mammoth.internal.mammoth.html.HtmlNode {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.html.HtmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlTag.java
package org.zwobble.mammoth.internal.mammoth.html;

public record HtmlTag(java.util.List<String> tagNames, java.util.Map<String, String> attributes, boolean isCollapsible, String separator) {
    public String defaultTagName() {
        return tagNames().get(0);
    }

    public boolean isVoid() {
        return defaultTagName().equals("br") || defaultTagName().equals("hr") || defaultTagName().equals("img");
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlText.java
package org.zwobble.mammoth.internal.mammoth.html;

public record HtmlText(String value) implements org.zwobble.mammoth.internal.mammoth.html.HtmlNode {
    public boolean isEmpty() {
        return value().equals("");
    }
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.html.HtmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/Html.java
package org.zwobble.mammoth.internal.mammoth.html;

import org.zwobble.mammoth.internal.mammoth.html.HtmlTag;
import org.zwobble.mammoth.internal.mammoth.html.HtmlElement;
import org.zwobble.mammoth.internal.mammoth.html.HtmlForceWrite;
import org.zwobble.mammoth.internal.mammoth.html.HtmlText;
import org.zwobble.mammoth.internal.mammoth.html.HtmlNode;

public class Html {
    public static HtmlElement element(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children) {
        return freshElement(tagNames, attributes, children);
    }
    public static HtmlElement collapsibleElement(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children) {
        var tag = new HtmlTag(tagNames, attributes, true, "");
        return new HtmlElement(tag, children);
    }
    public static HtmlElement freshElement(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children) {
        var tag = new HtmlTag(tagNames, attributes, false, "");
        return new HtmlElement(tag, children);
    }
    public static HtmlElement collapsibleElementWithSeparator(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children, String separator) {
        var tag = new HtmlTag(tagNames, attributes, true, separator);
        return new HtmlElement(tag, children);
    }
    public static HtmlElement freshElementWithSeparator(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children, String separator) {
        var tag = new HtmlTag(tagNames, attributes, false, separator);
        return new HtmlElement(tag, children);
    }
    public static HtmlForceWrite forceWrite() {
        // TODO: support top-level variables
        return new HtmlForceWrite();
    }
    public static HtmlText text(String value) {
        return new HtmlText(value);
    }
    public static java.util.List<? extends HtmlNode> stripEmpty(java.util.List<? extends HtmlNode> nodes) {
        return nodes.stream().flatMap((node) -> stripEmptyNode(node).stream()).toList();
    }
    public static java.util.List<? extends HtmlNode> stripEmptyNode(HtmlNode node) {
        return node.accept(new HtmlNode.Visitor<>() {
            @Override
            public java.util.List<org.zwobble.mammoth.internal.mammoth.html.HtmlNode> visit(HtmlElement node) {
                var children = stripEmpty(node.children());
                if (!node.isVoid() && children.size() == 0) {
                    return java.util.List.of();
                } else {
                    return java.util.List.of(new HtmlElement(node.tag(), children));
                }
            }
            @Override
            public java.util.List<org.zwobble.mammoth.internal.mammoth.html.HtmlNode> visit(HtmlForceWrite node) {
                return java.util.List.of(node);
            }
            @Override
            public java.util.List<org.zwobble.mammoth.internal.mammoth.html.HtmlNode> visit(HtmlText node) {
                if (node.isEmpty()) {
                    return java.util.List.of();
                } else {
                    return java.util.List.of(node);
                }
            }
        });
    }
    public static java.util.List<? extends HtmlNode> collapse(java.util.List<? extends HtmlNode> nodes) {
        var collapsed = new java.util.ArrayList<org.zwobble.mammoth.internal.mammoth.html.HtmlNode>();

        for (var node : nodes) {
            collapsingAdd(collapsed, node);
        }

        return collapsed;
    }
    public static void collapsingAdd(java.util.List<HtmlNode> collapsed, HtmlNode node) {
        var collapsedNode = collapseNode(node);
        if (!tryCollapse(collapsed, collapsedNode)) {
            collapsed.add(collapsedNode);
        }
    }
    public static HtmlNode collapseNode(HtmlNode node) {
        return node.accept(new HtmlNode.Visitor<>() {
            @Override
            public org.zwobble.mammoth.internal.mammoth.html.HtmlNode visit(HtmlElement node) {
                return new HtmlElement(node.tag(), collapse(node.children()));
            }
            @Override
            public org.zwobble.mammoth.internal.mammoth.html.HtmlNode visit(HtmlForceWrite node) {
                return node;
            }
            @Override
            public org.zwobble.mammoth.internal.mammoth.html.HtmlNode visit(HtmlText node) {
                return node;
            }
        });
    }
    public static boolean tryCollapse(java.util.List<HtmlNode> collapsed, HtmlNode node) {
        if (collapsed.size() == 0) {
            return false;
        }

        var last = collapsed.get(collapsed.size() - 1);

        if (!(node instanceof HtmlElement)) {
            return false;
        }
        var node_HtmlElement = (org.zwobble.mammoth.internal.mammoth.html.HtmlElement) node;

        if (!(last instanceof HtmlElement)) {
            return false;
        }
        var last_HtmlElement = (org.zwobble.mammoth.internal.mammoth.html.HtmlElement) last;

        if (!node_HtmlElement.isCollapsible() || !(node_HtmlElement.tagNames().contains(last_HtmlElement.defaultTagName()) && node_HtmlElement.attributes().equals(last_HtmlElement.attributes()))) {
            return false;
        }

        if (!node_HtmlElement.separator().equals("")) {
            ((java.util.List<HtmlNode>) last_HtmlElement.children()).add(text(node_HtmlElement.separator()));
        }

        for (var child : node_HtmlElement.children()) {
            collapsingAdd((java.util.List<HtmlNode>) last_HtmlElement.children(), child);
        }

        return true;
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlTests.java
package org.zwobble.mammoth.internal.mammoth.html;

import org.zwobble.mammoth.internal.mammoth.html.Html;
import static org.zwobble.precisely.Matchers.equalTo;
import static org.zwobble.precisely.AssertThat.assertThat;

public class HtmlTests {
    @org.junit.jupiter.api.Nested
    public class StripEmpty {
        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("text nodes with text are not stripped")
        public void textNodesWithTextAreNotStripped() {
            var nodes = java.util.List.of(Html.text("H"));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.text("H"))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("empty text nodes are stripped")
        public void emptyTextNodesAreStripped() {
            var nodes = java.util.List.of(Html.text(""));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of()));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with non-empty children are not stripped")
        public void elementsWithNonEmptyChildrenAreNotStripped() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("H"))));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.element(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("H"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with no children are stripped")
        public void elementsWithNoChildrenAreStripped() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of()));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with only empty children are stripped")
        public void elementsWithOnlyEmptyChildrenAreStripped() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text(""))));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of()));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("empty children are removed")
        public void emptyChildrenAreRemoved() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("ul"), java.util.Map.ofEntries(), java.util.List.of(Html.element(java.util.List.of("li"), java.util.Map.ofEntries(), java.util.List.of(Html.text(""))), Html.element(java.util.List.of("li"), java.util.Map.ofEntries(), java.util.List.of(Html.text("H"))))));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.element(java.util.List.of("ul"), java.util.Map.ofEntries(), java.util.List.of(Html.element(java.util.List.of("li"), java.util.Map.ofEntries(), java.util.List.of(Html.text("H"))))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("self-closing elements are never empty")
        public void selfClosingElementsAreNeverEmpty() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("br"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.element(java.util.List.of("br"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("force writes are never empty")
        public void forceWritesAreNeverEmpty() {
            var nodes = java.util.List.of(Html.forceWrite());

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.forceWrite())));
        }
    }@org.junit.jupiter.api.Nested
    public class Collapse {
        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("collapsing does nothing to single text node")
        public void collapsingDoesNothingToSingleTextNode() {
            var nodes = java.util.List.of(Html.text("Bluebells"));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.text("Bluebells"))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive fresh elements are not collapsed")
        public void consecutiveFreshElementsAreNotCollapsed() {
            var nodes = java.util.List.of(Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()), Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()), Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with different tag names are not collapsed")
        public void elementsWithDifferentTagNamesAreNotCollapsed() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("div"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("div"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with different attributes are not collapsed")
        public void elementsWithDifferentAttributesAreNotCollapsed() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("id", "a")), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("id", "a")), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive collapsible elements are collapsed if they have the same tag name and no attributes")
        public void consecutiveCollapsibleElementsAreCollapsedIfTheyHaveTheSameTagNameAndNoAttributes() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"), Html.text("Two"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive collapsible elements are collapsed if they have the same tag name and same attributes")
        public void consecutiveCollapsibleElementsAreCollapsedIfTheyHaveTheSameTagNameAndSameAttributes() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("a", "1"), java.util.Map.entry("b", "2")), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("b", "2"), java.util.Map.entry("a", "1")), java.util.List.of(Html.text("Two"))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("a", "1"), java.util.Map.entry("b", "2")), java.util.List.of(Html.text("One"), Html.text("Two"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("children of elements are collapsed")
        public void childrenOfElementsAreCollapsed() {
            var nodes = java.util.List.of(Html.freshElement(java.util.List.of("div"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.freshElement(java.util.List.of("div"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"), Html.text("Two"))))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("children of collapsed element can collapse with children of previous element")
        public void childrenOfCollapsedElementCanCollapseWithChildrenOfPreviousElement() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("blockquote"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))))), Html.collapsibleElement(java.util.List.of("blockquote"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("blockquote"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"), Html.text("Two"))))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("collapsible element can collapse into previous fresh element")
        public void collapsibleElementCanCollapseIntoPreviousFreshElement() {
            var nodes = java.util.List.of(Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive elements can collapse if second element has choice of tag names including main tag name of first element")
        public void consecutiveElementsCanCollapseIfSecondElementHasChoiceOfTagNamesIncludingMainTagNameOfFirstElement() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("ol"), java.util.Map.ofEntries(), java.util.List.of()), Html.collapsibleElement(java.util.List.of("ul", "ol"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("ol"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive elements cannot collapse if second element has tag name as non-main tag name of first element")
        public void consecutiveElementsCannotCollapseIfSecondElementHasTagNameAsNonMainTagNameOfFirstElement() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("ul", "ol"), java.util.Map.ofEntries(), java.util.List.of()), Html.collapsibleElement(java.util.List.of("ol"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("ul", "ol"), java.util.Map.ofEntries(), java.util.List.of()), Html.collapsibleElement(java.util.List.of("ol"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("when separator is present then separator is prepended to collapsed element")
        public void whenSeparatorIsPresentThenSeparatorIsPrependedToCollapsedElement() {
            var nodes = java.util.List.of(Html.freshElement(java.util.List.of("pre"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Hello"))), Html.collapsibleElementWithSeparator(java.util.List.of("pre"), java.util.Map.ofEntries(), java.util.List.of(Html.text(" the"), Html.text("re")), "\n"));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.freshElement(java.util.List.of("pre"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Hello"), Html.text("\n"), Html.text(" the"), Html.text("re"))))));
        }
    }}

==============

╷
├─ JUnit Jupiter ✔
│  ├─ StylesTests ✔
│  │  ├─ paragraph style can be found by ID ✘ 
│  │  │        Expected:
│  │  │          optional value:
│  │  │            name:
│  │  │              optional value:
│  │  │                "Heading 1"
│  │  │        but:
│  │  │          was empty
│  │  └─ paragraph style is none if no style with that ID exists ✔
│  └─ HtmlTests ✔
│     ├─ Collapse ✔
│     │  ├─ consecutive elements can collapse if second element has choice of tag names incl... ✔
│     │  ├─ elements with different attributes are not collapsed ✔
│     │  ├─ when separator is present then separator is prepended to collapsed element ✔
│     │  ├─ collapsing does nothing to single text node ✔
│     │  ├─ collapsible element can collapse into previous fresh element ✔
│     │  ├─ consecutive fresh elements are not collapsed ✔
│     │  ├─ elements with different tag names are not collapsed ✔
│     │  ├─ consecutive collapsible elements are collapsed if they have the same tag name an... ✔
│     │  ├─ children of elements are collapsed ✔
│     │  ├─ consecutive collapsible elements are collapsed if they have the same tag name an... ✔
│     │  ├─ consecutive elements cannot collapse if second element has tag name as non-main ... ✔
│     │  └─ children of collapsed element can collapse with children of previous element ✔
│     └─ StripEmpty ✔
│        ├─ text nodes with text are not stripped ✔
│        ├─ force writes are never empty ✔
│        ├─ elements with no children are stripped ✔
│        ├─ empty text nodes are stripped ✔
│        ├─ self-closing elements are never empty ✔
│        ├─ empty children are removed ✔
│        ├─ elements with non-empty children are not stripped ✔
│        └─ elements with only empty children are stripped ✔
└─ JUnit Vintage ✔

Failures (1):
  JUnit Jupiter:StylesTests:paragraph style can be found by ID
    MethodSource [className = 'org.zwobble.mammoth.internal.mammoth.docx.styles.StylesTests', methodName = 'paragraphStyleCanBeFoundByID', methodParameterTypes = '']
    => java.lang.AssertionError: 
Expected:
  optional value:
    name:
      optional value:
        "Heading 1"
but:
  was empty
       org.zwobble.precisely.AssertThat.assertThat(AssertThat.java:15)
       org.zwobble.mammoth.internal.mammoth.docx.styles.StylesTests.paragraphStyleCanBeFoundByID(Unknown Source)
       java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
       java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
       java.base/java.lang.reflect.Method.invoke(Method.java:568)
       org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)
       org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
       org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
       org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
       [...]

Test run finished after TIME ms
[         6 containers found      ]
[         0 containers skipped    ]
[         6 containers started    ]
[         0 containers aborted    ]
[         6 containers successful ]
[         0 containers failed     ]
[        22 tests found           ]
[         0 tests skipped         ]
[        22 tests started         ]
[         0 tests aborted         ]
[        21 tests successful      ]
[         1 tests failed          ]
