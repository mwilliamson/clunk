Source path: src/mammoth/documents.clunk
sealed interface DocumentElement {
}

record Bookmark(name: String) <: DocumentElement

record BreakLine() <: DocumentElement

record BreakPage() <: DocumentElement

record BreakColumn() <: DocumentElement

record Comment(
    commentId: String,
    body: List[DocumentElement],
    authorName: Option[String],
    authorInitials: Option[String],
)

record CommentReference(commentId: String) <: DocumentElement

record Document(
    children: List[DocumentElement],
    notes: List[Note],
    comments: List[Comment],
)

record Hyperlink(
    href: String,
    targetFrame: Option[String],
    children: List[DocumentElement],
) <: DocumentElement

record Image(
    altText: Option[String],
    contentType: Option[String],
) <: DocumentElement

record Note(
    noteType: NoteType,
    id: String,
    body: List[DocumentElement],
)

enum NoteType {
    FOOTNOTE,
    ENDNOTE,
}

record NoteReference(
    noteType: NoteType,
    noteId: String,
) <: DocumentElement

record NumberingLevel(
    levelIndex: String,
    isOrdered: Bool,
)

record NumberingStyle(
    numId: String,
)

record Paragraph(
    style: Option[String],
    numbering: Option[NumberingLevel],
    indent: ParagraphIndent,
    children: List[DocumentElement],
) <: DocumentElement

record ParagraphIndent(
    start: Option[String],
    end: Option[String],
    firstLine: Option[String],
    hanging: Option[String],
)

record Run(
    isBold: Bool,
    isItalic: Bool,
    isUnderline: Bool,
    isStrikethrough: Bool,
    isAllCaps: Bool,
    isSmallCaps: Bool,
    verticalAlignment: VerticalAlignment,
    style: Option[String],
    children: List[DocumentElement],
) <: DocumentElement

record Style(
    styleId: String,
    name: Option[String],
)

record Tab() <: DocumentElement

record Table(
    style: Option[Style],
    children: List[DocumentElement],
) <: DocumentElement

record TableCell(
    rowspan: Int,
    colspan: Int,
    children: List[DocumentElement],
) <: DocumentElement

record TableRow(
    children: List[DocumentElement],
    isHeader: Bool,
) <: DocumentElement

record Text(
    value: String,
) <: DocumentElement

enum VerticalAlignment {
    SUPERSCRIPT,
    SUBSCRIPT,
    BASELINE
}


==============

Source path: src/mammoth/html.clunk
sealed interface HtmlNode {
}

record HtmlAttribute(name: String, value: String)

fun element(tagName: String, attributes: List[HtmlAttribute], children: List[HtmlNode]) -> HtmlElement {
    return freshElement(tagName, attributes, children);
}

fun collapsibleElement(tagName: String, attributes: List[HtmlAttribute], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag([tagName], attributes, true, "");
    return HtmlElement(tag, children);
}

fun freshElement(tagName: String, attributes: List[HtmlAttribute], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag([tagName], attributes, false, "");
    return HtmlElement(tag, children);
}

record HtmlElement(tag: HtmlTag, children: List[HtmlNode]) <: HtmlNode {
    property defaultTagName: String {
        return tag.defaultTagName;
    }

    property isCollapsible: Bool {
        return tag.isCollapsible;
    }

    property isVoid: Bool {
        return tag.isVoid;
    }
}

fun forceWrite() -> HtmlForceWrite {
    // TODO: support top-level variables
    return HtmlForceWrite();
}

record HtmlForceWrite() <: HtmlNode

record HtmlTag(
    tagNames: List[String],
    attributes: List[HtmlAttribute],
    isCollapsible: Bool,
    separator: String,
) {
    property defaultTagName: String {
        return tagNames.get(0);
    }

    property isVoid: Bool {
        return defaultTagName == "br" ||
            defaultTagName == "hr" ||
            defaultTagName == "img";
    }
}

fun text(value: String) -> HtmlText {
    return HtmlText(value);
}

record HtmlText(value: String) <: HtmlNode {
    property isEmpty: Bool {
        return value == "";
    }
}

fun stripEmpty(nodes: List[HtmlNode]) -> List[HtmlNode] {
    return nodes.flatMap[HtmlNode](stripEmptyNode);
}

fun stripEmptyNode(node: HtmlNode) -> List[HtmlNode] {
    switch (node) {
        case HtmlElement {
            var children = stripEmpty(node.children);
            if (!node.isVoid && children.length() == 0) {
                return [];
            } else {
                return [HtmlElement(node.tag, children)];
            }
        }

        case HtmlForceWrite {
            return [node];
        }

        case HtmlText {
            if (node.isEmpty) {
                return [];
            } else {
                return [node];
            }
        }
    }
}

fun collapse(nodes: List[HtmlNode]) -> List[HtmlNode] {
    var collapsed = MutableList[HtmlNode]();

    for (var node in nodes) {
        collapsingAdd(collapsed, node);
    }

    return collapsed;
}

fun collapsingAdd(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Unit {
    var collapsedNode = collapseNode(node);
    if (!tryCollapse(collapsed, collapsedNode)) {
        collapsed.add(collapsedNode);
    }
}

fun collapseNode(node: HtmlNode) -> HtmlNode {
    switch (node) {
        case HtmlElement {
            return HtmlElement(
                node.tag,
                collapse(node.children),
            );
        }

        case HtmlForceWrite {
            return node;
        }

        case HtmlText {
            return node;
        }
    }
}

fun tryCollapse(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Bool {
    if (collapsed.length() == 0) {
        return false;
    }

    var last = collapsed.last();

    if (!(node instanceof HtmlElement)) {
        return false;
    }

    if (!(last instanceof HtmlElement)) {
        return false;
    }

    if (!node.isCollapsible || node.defaultTagName != last.defaultTagName) {
        return false;
    }

    for (var child in node.children) {
        (last.children as MutableList[HtmlNode]).add(child);
    }

    return true;
}


==============

Source path: src/mammoth/html.test.clunk
import stdlib/assertions.assertThat;
import stdlib/matchers.equalTo;
import mammoth/html;

testSuite "stripEmpty" {
    test "text nodes with text are not stripped" {
        var nodes = [html.text("H")];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.text("H")]));
    }

    test "empty text nodes are stripped" {
        var nodes = [html.text("")];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "elements with non-empty children are not stripped" {
        var nodes = [html.element("p", [], [html.text("H")])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.element("p", [], [html.text("H")])]));
    }

    test "elements with no children are stripped" {
        var nodes = [html.element("p", [], [])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "elements with only empty children are stripped" {
        var nodes = [html.element("p", [], [html.text("")])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "empty children are removed" {
        var nodes = [
            html.element("ul", [], [
                html.element("li", [], [html.text("")]),
                html.element("li", [], [html.text("H")]),
            ]),
        ];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([
            html.element("ul", [], [
                html.element("li", [], [html.text("H")]),
            ]),
        ]));
    }

    test "self-closing elements are never empty" {
        var nodes = [html.element("br", [], [])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.element("br", [], [])]));
    }

    test "force writes are never empty" {
        var nodes = [html.forceWrite()];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.forceWrite()]));
    }
}

testSuite "collapse" {
    test "collapsing does nothing to single text node" {
        var nodes = [html.text("Bluebells")];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([html.text("Bluebells")]));
    }

    test "consecutive fresh elements are not collapsed" {
        var nodes = [
            html.freshElement("p", [], []),
            html.freshElement("p", [], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement("p", [], []),
            html.freshElement("p", [], []),
        ]));
    }

    test "elements with different tag names are not collapsed" {
        var nodes = [
            html.collapsibleElement("p", [], [html.text("One")]),
            html.collapsibleElement("div", [], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement("p", [], [html.text("One")]),
            html.collapsibleElement("div", [], [html.text("Two")]),
        ]));
    }

    test "consecutive collapsible elements are collapsed if they have the same tag and attributes" {
        var nodes = [
            html.collapsibleElement("p", [], [html.text("One")]),
            html.collapsibleElement("p", [], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement("p", [], [html.text("One"), html.text("Two")]),
        ]));
    }

    test "children of elements are collapsed" {
        var nodes = [
            html.freshElement("div", [], [
                html.collapsibleElement("p", [], [html.text("One")]),
                html.collapsibleElement("p", [], [html.text("Two")]),
            ]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement("div", [], [
                html.collapsibleElement("p", [], [html.text("One"), html.text("Two")]),
            ]),
        ]));
    }
}


==============

Output path: mammoth/documents.ts
type DocumentElement = Bookmark | BreakLine | BreakPage | BreakColumn | CommentReference | Hyperlink | Image | NoteReference | Paragraph | Run | Tab | Table | TableCell | TableRow | Text;

class Bookmark {
    readonly type: "Bookmark" = "Bookmark";
    readonly name: string;

    constructor(name: string) {
        this.name = name;
    }
}

class BreakLine {
    readonly type: "BreakLine" = "BreakLine";
}

class BreakPage {
    readonly type: "BreakPage" = "BreakPage";
}

class BreakColumn {
    readonly type: "BreakColumn" = "BreakColumn";
}

class Comment {
    readonly commentId: string;
    readonly body: ReadonlyArray<DocumentElement>;
    readonly authorName: string | null;
    readonly authorInitials: string | null;

    constructor(commentId: string, body: ReadonlyArray<DocumentElement>, authorName: string | null, authorInitials: string | null) {
        this.commentId = commentId;
        this.body = body;
        this.authorName = authorName;
        this.authorInitials = authorInitials;
    }
}

class CommentReference {
    readonly type: "CommentReference" = "CommentReference";
    readonly commentId: string;

    constructor(commentId: string) {
        this.commentId = commentId;
    }
}

class Document {
    readonly children: ReadonlyArray<DocumentElement>;
    readonly notes: ReadonlyArray<Note>;
    readonly comments: ReadonlyArray<Comment>;

    constructor(children: ReadonlyArray<DocumentElement>, notes: ReadonlyArray<Note>, comments: ReadonlyArray<Comment>) {
        this.children = children;
        this.notes = notes;
        this.comments = comments;
    }
}

class Hyperlink {
    readonly type: "Hyperlink" = "Hyperlink";
    readonly href: string;
    readonly targetFrame: string | null;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(href: string, targetFrame: string | null, children: ReadonlyArray<DocumentElement>) {
        this.href = href;
        this.targetFrame = targetFrame;
        this.children = children;
    }
}

class Image {
    readonly type: "Image" = "Image";
    readonly altText: string | null;
    readonly contentType: string | null;

    constructor(altText: string | null, contentType: string | null) {
        this.altText = altText;
        this.contentType = contentType;
    }
}

class Note {
    readonly noteType: NoteType;
    readonly id: string;
    readonly body: ReadonlyArray<DocumentElement>;

    constructor(noteType: NoteType, id: string, body: ReadonlyArray<DocumentElement>) {
        this.noteType = noteType;
        this.id = id;
        this.body = body;
    }
}

enum NoteType {
    FOOTNOTE,
    ENDNOTE,
}

class NoteReference {
    readonly type: "NoteReference" = "NoteReference";
    readonly noteType: NoteType;
    readonly noteId: string;

    constructor(noteType: NoteType, noteId: string) {
        this.noteType = noteType;
        this.noteId = noteId;
    }
}

class NumberingLevel {
    readonly levelIndex: string;
    readonly isOrdered: boolean;

    constructor(levelIndex: string, isOrdered: boolean) {
        this.levelIndex = levelIndex;
        this.isOrdered = isOrdered;
    }
}

class NumberingStyle {
    readonly numId: string;

    constructor(numId: string) {
        this.numId = numId;
    }
}

class Paragraph {
    readonly type: "Paragraph" = "Paragraph";
    readonly style: string | null;
    readonly numbering: NumberingLevel | null;
    readonly indent: ParagraphIndent;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(style: string | null, numbering: NumberingLevel | null, indent: ParagraphIndent, children: ReadonlyArray<DocumentElement>) {
        this.style = style;
        this.numbering = numbering;
        this.indent = indent;
        this.children = children;
    }
}

class ParagraphIndent {
    readonly start: string | null;
    readonly end: string | null;
    readonly firstLine: string | null;
    readonly hanging: string | null;

    constructor(start: string | null, end: string | null, firstLine: string | null, hanging: string | null) {
        this.start = start;
        this.end = end;
        this.firstLine = firstLine;
        this.hanging = hanging;
    }
}

class Run {
    readonly type: "Run" = "Run";
    readonly isBold: boolean;
    readonly isItalic: boolean;
    readonly isUnderline: boolean;
    readonly isStrikethrough: boolean;
    readonly isAllCaps: boolean;
    readonly isSmallCaps: boolean;
    readonly verticalAlignment: VerticalAlignment;
    readonly style: string | null;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(isBold: boolean, isItalic: boolean, isUnderline: boolean, isStrikethrough: boolean, isAllCaps: boolean, isSmallCaps: boolean, verticalAlignment: VerticalAlignment, style: string | null, children: ReadonlyArray<DocumentElement>) {
        this.isBold = isBold;
        this.isItalic = isItalic;
        this.isUnderline = isUnderline;
        this.isStrikethrough = isStrikethrough;
        this.isAllCaps = isAllCaps;
        this.isSmallCaps = isSmallCaps;
        this.verticalAlignment = verticalAlignment;
        this.style = style;
        this.children = children;
    }
}

class Style {
    readonly styleId: string;
    readonly name: string | null;

    constructor(styleId: string, name: string | null) {
        this.styleId = styleId;
        this.name = name;
    }
}

class Tab {
    readonly type: "Tab" = "Tab";
}

class Table {
    readonly type: "Table" = "Table";
    readonly style: Style | null;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(style: Style | null, children: ReadonlyArray<DocumentElement>) {
        this.style = style;
        this.children = children;
    }
}

class TableCell {
    readonly type: "TableCell" = "TableCell";
    readonly rowspan: number;
    readonly colspan: number;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(rowspan: number, colspan: number, children: ReadonlyArray<DocumentElement>) {
        this.rowspan = rowspan;
        this.colspan = colspan;
        this.children = children;
    }
}

class TableRow {
    readonly type: "TableRow" = "TableRow";
    readonly children: ReadonlyArray<DocumentElement>;
    readonly isHeader: boolean;

    constructor(children: ReadonlyArray<DocumentElement>, isHeader: boolean) {
        this.children = children;
        this.isHeader = isHeader;
    }
}

class Text {
    readonly type: "Text" = "Text";
    readonly value: string;

    constructor(value: string) {
        this.value = value;
    }
}

enum VerticalAlignment {
    SUPERSCRIPT,
    SUBSCRIPT,
    BASELINE,
}
export {Bookmark, BreakColumn, BreakLine, BreakPage, Comment, CommentReference, Document, DocumentElement, Hyperlink, Image, Note, NoteReference, NoteType, NumberingLevel, NumberingStyle, Paragraph, ParagraphIndent, Run, Style, Tab, Table, TableCell, TableRow, Text, VerticalAlignment};


==============

Output path: mammoth/html.ts
type HtmlNode = HtmlElement | HtmlForceWrite | HtmlText;

class HtmlAttribute {
    readonly name: string;
    readonly value: string;

    constructor(name: string, value: string) {
        this.name = name;
        this.value = value;
    }
}

function element(tagName: string, attributes: ReadonlyArray<HtmlAttribute>, children: ReadonlyArray<HtmlNode>): HtmlElement {
    return freshElement(tagName, attributes, children);
}

function collapsibleElement(tagName: string, attributes: ReadonlyArray<HtmlAttribute>, children: ReadonlyArray<HtmlNode>): HtmlElement {
    let tag = new HtmlTag([tagName], attributes, true, "");
    return new HtmlElement(tag, children);
}

function freshElement(tagName: string, attributes: ReadonlyArray<HtmlAttribute>, children: ReadonlyArray<HtmlNode>): HtmlElement {
    let tag = new HtmlTag([tagName], attributes, false, "");
    return new HtmlElement(tag, children);
}

class HtmlElement {
    readonly type: "HtmlElement" = "HtmlElement";
    readonly tag: HtmlTag;
    readonly children: ReadonlyArray<HtmlNode>;

    constructor(tag: HtmlTag, children: ReadonlyArray<HtmlNode>) {
        this.tag = tag;
        this.children = children;
    }
    get defaultTagName(): string {
        return this.tag.defaultTagName;
    }

    get isCollapsible(): boolean {
        return this.tag.isCollapsible;
    }

    get isVoid(): boolean {
        return this.tag.isVoid;
    }
}

function forceWrite(): HtmlForceWrite {
    // TODO: support top-level variables
    return new HtmlForceWrite();
}

class HtmlForceWrite {
    readonly type: "HtmlForceWrite" = "HtmlForceWrite";
}

class HtmlTag {
    readonly tagNames: ReadonlyArray<string>;
    readonly attributes: ReadonlyArray<HtmlAttribute>;
    readonly isCollapsible: boolean;
    readonly separator: string;

    constructor(tagNames: ReadonlyArray<string>, attributes: ReadonlyArray<HtmlAttribute>, isCollapsible: boolean, separator: string) {
        this.tagNames = tagNames;
        this.attributes = attributes;
        this.isCollapsible = isCollapsible;
        this.separator = separator;
    }
    get defaultTagName(): string {
        return this.tagNames[0];
    }

    get isVoid(): boolean {
        return this.defaultTagName === "br" || this.defaultTagName === "hr" || this.defaultTagName === "img";
    }
}

function text(value: string): HtmlText {
    return new HtmlText(value);
}

class HtmlText {
    readonly type: "HtmlText" = "HtmlText";
    readonly value: string;

    constructor(value: string) {
        this.value = value;
    }
    get isEmpty(): boolean {
        return this.value === "";
    }
}

function stripEmpty(nodes: ReadonlyArray<HtmlNode>): ReadonlyArray<HtmlNode> {
    return nodes.flatMap(stripEmptyNode);
}

function stripEmptyNode(node: HtmlNode): ReadonlyArray<HtmlNode> {
    switch (node.type) {
        case "HtmlElement":
            let children = stripEmpty(node.children);
            if (!node.isVoid && children.length === 0) {
                return [];
            } else {
                return [new HtmlElement(node.tag, children)];
            }
        case "HtmlForceWrite":
            return [node];
        case "HtmlText":
            if (node.isEmpty) {
                return [];
            } else {
                return [node];
            }
    }
}

function collapse(nodes: ReadonlyArray<HtmlNode>): ReadonlyArray<HtmlNode> {
    let collapsed = new Array<HtmlNode>();

    for (let node of nodes) {
        collapsingAdd(collapsed, node);
    }

    return collapsed;
}

function collapsingAdd(collapsed: Array<HtmlNode>, node: HtmlNode): void {
    let collapsedNode = collapseNode(node);
    if (!tryCollapse(collapsed, collapsedNode)) {
        collapsed.push(collapsedNode);
    }
}

function collapseNode(node: HtmlNode): HtmlNode {
    switch (node.type) {
        case "HtmlElement":
            return new HtmlElement(node.tag, collapse(node.children));
        case "HtmlForceWrite":
            return node;
        case "HtmlText":
            return node;
    }
}

function tryCollapse(collapsed: Array<HtmlNode>, node: HtmlNode): boolean {
    if (collapsed.length === 0) {
        return false;
    }

    let last = collapsed[collapsed.length - 1];

    if (!(node.type === "HtmlElement")) {
        return false;
    }

    if (!(last.type === "HtmlElement")) {
        return false;
    }

    if (!node.isCollapsible || node.defaultTagName !== last.defaultTagName) {
        return false;
    }

    for (let child of node.children) {
        ((last.children) as Array<HtmlNode>).push(child);
    }

    return true;
}
export {HtmlAttribute, HtmlElement, HtmlForceWrite, HtmlNode, HtmlTag, HtmlText, collapse, collapseNode, collapsibleElement, collapsingAdd, element, forceWrite, freshElement, stripEmpty, stripEmptyNode, text, tryCollapse};


==============

Output path: mammoth/html.test.ts
import {assertThat} from "@mwilliamson/precisely";
import {deepEqualTo} from "@mwilliamson/precisely";
import * as html from "./html";

suite("stripEmpty", function () {
    test("text nodes with text are not stripped", function () {
        let nodes = [html.text("H")];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.text("H")]));
    });

    test("empty text nodes are stripped", function () {
        let nodes = [html.text("")];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([]));
    });

    test("elements with non-empty children are not stripped", function () {
        let nodes = [html.element("p", [], [html.text("H")])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.element("p", [], [html.text("H")])]));
    });

    test("elements with no children are stripped", function () {
        let nodes = [html.element("p", [], [])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([]));
    });

    test("elements with only empty children are stripped", function () {
        let nodes = [html.element("p", [], [html.text("")])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([]));
    });

    test("empty children are removed", function () {
        let nodes = [html.element("ul", [], [html.element("li", [], [html.text("")]), html.element("li", [], [html.text("H")])])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.element("ul", [], [html.element("li", [], [html.text("H")])])]));
    });

    test("self-closing elements are never empty", function () {
        let nodes = [html.element("br", [], [])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.element("br", [], [])]));
    });

    test("force writes are never empty", function () {
        let nodes = [html.forceWrite()];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.forceWrite()]));
    });
});

suite("collapse", function () {
    test("collapsing does nothing to single text node", function () {
        let nodes = [html.text("Bluebells")];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.text("Bluebells")]));
    });

    test("consecutive fresh elements are not collapsed", function () {
        let nodes = [html.freshElement("p", [], []), html.freshElement("p", [], [])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.freshElement("p", [], []), html.freshElement("p", [], [])]));
    });

    test("elements with different tag names are not collapsed", function () {
        let nodes = [html.collapsibleElement("p", [], [html.text("One")]), html.collapsibleElement("div", [], [html.text("Two")])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.collapsibleElement("p", [], [html.text("One")]), html.collapsibleElement("div", [], [html.text("Two")])]));
    });

    test("consecutive collapsible elements are collapsed if they have the same tag and attributes", function () {
        let nodes = [html.collapsibleElement("p", [], [html.text("One")]), html.collapsibleElement("p", [], [html.text("Two")])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.collapsibleElement("p", [], [html.text("One"), html.text("Two")])]));
    });

    test("children of elements are collapsed", function () {
        let nodes = [html.freshElement("div", [], [html.collapsibleElement("p", [], [html.text("One")]), html.collapsibleElement("p", [], [html.text("Two")])])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.freshElement("div", [], [html.collapsibleElement("p", [], [html.text("One"), html.text("Two")])])]));
    });
});


==============



  stripEmpty
    ✔ text nodes with text are not stripped
    ✔ empty text nodes are stripped
    ✔ elements with non-empty children are not stripped
    ✔ elements with no children are stripped
    ✔ elements with only empty children are stripped
    ✔ empty children are removed
    ✔ self-closing elements are never empty
    ✔ force writes are never empty

  collapse
    ✔ collapsing does nothing to single text node
    ✔ consecutive fresh elements are not collapsed
    ✔ elements with different tag names are not collapsed
    ✔ consecutive collapsible elements are collapsed if they have the same tag and attributes
    ✔ children of elements are collapsed


  13 passing (TIME)
