Source path: src/mammoth/documents.clunk
sealed interface DocumentElement {
}

interface HasChildren {
}

record Bookmark(name: String) <: DocumentElement

record BreakLine() <: DocumentElement

record BreakPage() <: DocumentElement

record BreakColumn() <: DocumentElement

record Comment(
    commentId: String,
    body: List[DocumentElement],
    authorName: Option[String],
    authorInitials: Option[String],
)

record CommentReference(commentId: String) <: DocumentElement

record Document(
    children: List[DocumentElement],
    notes: List[Note],
    comments: List[Comment],
) <: HasChildren

record Hyperlink(
    href: String,
    targetFrame: Option[String],
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record Image(
    altText: Option[String],
    contentType: Option[String],
) <: DocumentElement

record Note(
    noteType: NoteType,
    id: String,
    body: List[DocumentElement],
)

enum NoteType {
    FOOTNOTE,
    ENDNOTE,
}

record NoteReference(
    noteType: NoteType,
    noteId: String,
) <: DocumentElement

record NumberingLevel(
    levelIndex: String,
    isOrdered: Bool,
)

record NumberingStyle(
    numId: String,
)

record Paragraph(
    style: Option[String],
    numbering: Option[NumberingLevel],
    indent: ParagraphIndent,
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record ParagraphIndent(
    start: Option[String],
    end: Option[String],
    firstLine: Option[String],
    hanging: Option[String],
)

record Run(
    isBold: Bool,
    isItalic: Bool,
    isUnderline: Bool,
    isStrikethrough: Bool,
    isAllCaps: Bool,
    isSmallCaps: Bool,
    verticalAlignment: VerticalAlignment,
    style: Option[String],
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record Style(
    styleId: String,
    name: Option[String],
)

record Tab() <: DocumentElement

record Table(
    style: Option[Style],
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record TableCell(
    rowspan: Int,
    colspan: Int,
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record TableRow(
    children: List[DocumentElement],
    isHeader: Bool,
) <: DocumentElement, HasChildren

record Text(
    value: String,
) <: DocumentElement

enum VerticalAlignment {
    SUPERSCRIPT,
    SUBSCRIPT,
    BASELINE
}


==============

Source path: src/mammoth/docx/styles.clunk
import mammoth/xml.XmlElement;
import mammoth/xml.XmlElementList;

// TODO: deal with naming conflict with namespace class Styles
record DocumentStyles(paragraphStyles: Map[String, Style]) {
    fun findParagraphStyleById(name: String) -> Option[Style] {
        return none();
    }
}

record Style(styleId: String, name: Option[String])

fun readStylesXmlElement(element: XmlElement) -> DocumentStyles {
    var styleElements = element.findChildren("w:style");
    return DocumentStyles(readStyles(styleElements, "paragraph"));
}

fun readStyles(styleElements: XmlElementList, styleType: String) -> Map[String, Style] {
    return #[];
}


==============

Source path: src/mammoth/docx/styles.test.clunk
import stdlib/assertions.assertThat;
import stdlib/matchers.equalTo;
import stdlib/matchers.hasMember;
import stdlib/matchers.isNone;
import stdlib/matchers.isSome;
import mammoth/docx/styles.readStylesXmlElement;
import mammoth/docx/styles.Style;
import mammoth/xml;

test "paragraph style is none if no style with that ID exists" {
    var element = xml.element("w:styles", #[], []);

    var styles = readStylesXmlElement(element);

    assertThat(styles.findParagraphStyleById("Heading1"), isNone());
}

test "paragraph style can be found by ID" {
    var element = xml.element("w:styles", #[], [
        xml.element("w:style", #[["w:type", "paragraph"], ["w:styleId", "Heading1"]], [
            xml.element("w:name", #[["w:val", "Heading 1"]], []),
        ]),
    ]);

    var styles = readStylesXmlElement(element);

    assertThat(
        styles.findParagraphStyleById("Heading1"),
        isSome(hasMember(Style::name, isSome(equalTo("Heading 1")))),
    );
}


==============

Source path: src/mammoth/html.clunk
sealed interface HtmlNode {
}

fun element(tagNames: List[String], attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    return freshElement(tagNames, attributes, children);
}

fun collapsibleElement(tagNames: List[String], attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, true, "");
    return HtmlElement(tag, children);
}

fun freshElement(tagNames: List[String], attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, false, "");
    return HtmlElement(tag, children);
}

fun collapsibleElementWithSeparator(
    tagNames: List[String],
    attributes: Map[String, String],
    children: List[HtmlNode],
    separator: String,
) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, true, separator);
    return HtmlElement(tag, children);
}

fun freshElementWithSeparator(
    tagNames: List[String],
    attributes: Map[String, String],
    children: List[HtmlNode],
    separator: String,
) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, false, separator);
    return HtmlElement(tag, children);
}

record HtmlElement(tag: HtmlTag, children: List[HtmlNode]) <: HtmlNode {
    property attributes: Map[String, String] {
        return tag.attributes;
    }

    property defaultTagName: String {
        return tag.defaultTagName;
    }

    property tagNames: List[String] {
        return tag.tagNames;
    }

    property isCollapsible: Bool {
        return tag.isCollapsible;
    }

    property isVoid: Bool {
        return tag.isVoid;
    }

    property separator: String {
        return tag.separator;
    }
}

fun forceWrite() -> HtmlForceWrite {
    // TODO: support top-level variables
    return HtmlForceWrite();
}

record HtmlForceWrite() <: HtmlNode

record HtmlTag(
    tagNames: List[String],
    attributes: Map[String, String],
    isCollapsible: Bool,
    separator: String,
) {
    property defaultTagName: String {
        return tagNames.get(0);
    }

    property isVoid: Bool {
        return defaultTagName == "br" ||
            defaultTagName == "hr" ||
            defaultTagName == "img";
    }
}

fun text(value: String) -> HtmlText {
    return HtmlText(value);
}

record HtmlText(value: String) <: HtmlNode {
    property isEmpty: Bool {
        return value == "";
    }
}

fun stripEmpty(nodes: List[HtmlNode]) -> List[HtmlNode] {
    return [
        for node in nodes
        for child in stripEmptyNode(node)
        yield child
    ];
}

fun stripEmptyNode(node: HtmlNode) -> List[HtmlNode] {
    switch (node) {
        case HtmlElement {
            var children = stripEmpty(node.children);
            if (!node.isVoid && children.length() == 0) {
                return [];
            } else {
                return [HtmlElement(node.tag, children)];
            }
        }

        case HtmlForceWrite {
            return [node];
        }

        case HtmlText {
            if (node.isEmpty) {
                return [];
            } else {
                return [node];
            }
        }
    }
}

fun collapse(nodes: List[HtmlNode]) -> List[HtmlNode] {
    var collapsed = MutableList[HtmlNode]();

    for (var node in nodes) {
        collapsingAdd(collapsed, node);
    }

    return collapsed;
}

fun collapsingAdd(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Unit {
    var collapsedNode = collapseNode(node);
    if (!tryCollapse(collapsed, collapsedNode)) {
        collapsed.add(collapsedNode);
    }
}

fun collapseNode(node: HtmlNode) -> HtmlNode {
    switch (node) {
        case HtmlElement {
            return HtmlElement(
                node.tag,
                collapse(node.children),
            );
        }

        case HtmlForceWrite {
            return node;
        }

        case HtmlText {
            return node;
        }
    }
}

fun tryCollapse(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Bool {
    if (collapsed.length() == 0) {
        return false;
    }

    var last = collapsed.last();

    if (!(node instanceof HtmlElement)) {
        return false;
    }

    if (!(last instanceof HtmlElement)) {
        return false;
    }

    if (!node.isCollapsible || !(node.tagNames.contains(last.defaultTagName) && node.attributes == last.attributes)) {
        return false;
    }

    if (node.separator != "") {
        (last.children as MutableList[HtmlNode]).add(text(node.separator));
    }

    for (var child in node.children) {
        collapsingAdd(last.children as MutableList[HtmlNode], child);
    }

    return true;
}


==============

Source path: src/mammoth/html.test.clunk
import stdlib/assertions.assertThat;
import stdlib/matchers.equalTo;
import mammoth/html;

testSuite "stripEmpty" {
    test "text nodes with text are not stripped" {
        var nodes = [html.text("H")];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.text("H")]));
    }

    test "empty text nodes are stripped" {
        var nodes = [html.text("")];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "elements with non-empty children are not stripped" {
        var nodes = [html.element(["p"], #[], [html.text("H")])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.element(["p"], #[], [html.text("H")])]));
    }

    test "elements with no children are stripped" {
        var nodes = [html.element(["p"], #[], [])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "elements with only empty children are stripped" {
        var nodes = [html.element(["p"], #[], [html.text("")])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "empty children are removed" {
        var nodes = [
            html.element(["ul"], #[], [
                html.element(["li"], #[], [html.text("")]),
                html.element(["li"], #[], [html.text("H")]),
            ]),
        ];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([
            html.element(["ul"], #[], [
                html.element(["li"], #[], [html.text("H")]),
            ]),
        ]));
    }

    test "self-closing elements are never empty" {
        var nodes = [html.element(["br"], #[], [])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.element(["br"], #[], [])]));
    }

    test "force writes are never empty" {
        var nodes = [html.forceWrite()];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.forceWrite()]));
    }
}

testSuite "collapse" {
    test "collapsing does nothing to single text node" {
        var nodes = [html.text("Bluebells")];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([html.text("Bluebells")]));
    }

    test "consecutive fresh elements are not collapsed" {
        var nodes = [
            html.freshElement(["p"], #[], []),
            html.freshElement(["p"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["p"], #[], []),
            html.freshElement(["p"], #[], []),
        ]));
    }

    test "elements with different tag names are not collapsed" {
        var nodes = [
            html.collapsibleElement(["p"], #[], [html.text("One")]),
            html.collapsibleElement(["div"], #[], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[], [html.text("One")]),
            html.collapsibleElement(["div"], #[], [html.text("Two")]),
        ]));
    }

    test "elements with different attributes are not collapsed" {
        var nodes = [
            html.collapsibleElement(["p"], #[["id", "a"]], [html.text("One")]),
            html.collapsibleElement(["p"], #[], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[["id", "a"]], [html.text("One")]),
            html.collapsibleElement(["p"], #[], [html.text("Two")]),
        ]));
    }

    test "consecutive collapsible elements are collapsed if they have the same tag name and no attributes" {
        var nodes = [
            html.collapsibleElement(["p"], #[], [html.text("One")]),
            html.collapsibleElement(["p"], #[], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[], [html.text("One"), html.text("Two")]),
        ]));
    }

    test "consecutive collapsible elements are collapsed if they have the same tag name and same attributes" {
        var nodes = [
            html.collapsibleElement(["p"], #[["a", "1"], ["b", "2"]], [html.text("One")]),
            html.collapsibleElement(["p"], #[["b", "2"], ["a", "1"]], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[["a", "1"], ["b", "2"]], [html.text("One"), html.text("Two")]),
        ]));
    }

    test "children of elements are collapsed" {
        var nodes = [
            html.freshElement(["div"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One")]),
                html.collapsibleElement(["p"], #[], [html.text("Two")]),
            ]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["div"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One"), html.text("Two")]),
            ]),
        ]));
    }

    test "children of collapsed element can collapse with children of previous element" {
        var nodes = [
            html.collapsibleElement(["blockquote"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One")]),
            ]),
            html.collapsibleElement(["blockquote"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("Two")]),
            ]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["blockquote"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One"), html.text("Two")]),
            ]),
        ]));
    }

    test "collapsible element can collapse into previous fresh element" {
        var nodes = [
            html.freshElement(["p"], #[], []),
            html.collapsibleElement(["p"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["p"], #[], []),
        ]));
    }

    test "consecutive elements can collapse if second element has choice of tag names including main tag name of first element" {
        var nodes = [
            html.collapsibleElement(["ol"], #[], []),
            html.collapsibleElement(["ul", "ol"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["ol"], #[], []),
        ]));
    }

    test "consecutive elements cannot collapse if second element has tag name as non-main tag name of first element" {
        var nodes = [
            html.collapsibleElement(["ul", "ol"], #[], []),
            html.collapsibleElement(["ol"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["ul", "ol"], #[], []),
            html.collapsibleElement(["ol"], #[], []),
        ]));
    }

    test "when separator is present then separator is prepended to collapsed element" {
        var nodes = [
            html.freshElement(["pre"], #[], [html.text("Hello")]),
            html.collapsibleElementWithSeparator(
                ["pre"],
                #[],
                [html.text(" the"), html.text("re")],
                "\n"
            ),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["pre"], #[], [
                html.text("Hello"),
                html.text("\n"),
                html.text(" the"),
                html.text("re"),
            ]),
        ]));
    }
}


==============

Source path: src/mammoth/xml.clunk
sealed interface XmlNode {
}

interface XmlElementOrEmpty {
}

fun element(
    name: String,
    attributes: Map[String, String],
    children: List[XmlNode],
) -> XmlElement {
    return XmlElement(name, attributes, children);
}

record XmlElement(
    name: String,
    attributes: Map[String, String],
    children: List[XmlNode],
) <: XmlNode, XmlElementOrEmpty {
    fun findChildren(name: String) -> XmlElementList {
        return XmlElementList([
            for child in children
            if child instanceof XmlElement
            if child.name == name
            yield child
        ]);
    }

    fun findChildOrEmpty(name: String) -> XmlElementOrEmpty {
        for (var child in children) {
            if (child instanceof XmlElement) {
                if (child.name == name) {
                    return child;
                }
            }
        }

        return XmlEmpty();
    }

    fun getAttribute(name: String) -> Option[String] {
        return attributes.get(name);
    }
}

record XmlElementList(
    elements: List[XmlElement],
)

record XmlEmpty() <: XmlElementOrEmpty {
    fun findChildren(name: String) -> XmlElementList {
        return XmlElementList([]);
    }

    fun getAttribute(name: String) -> Option[String] {
        return none();
    }
}


record XmlTextNode(
    value: String,
) <: XmlNode


==============

Output path: mammoth/documents.ts
type DocumentElement = Bookmark | BreakLine | BreakPage | BreakColumn | CommentReference | Hyperlink | Image | NoteReference | Paragraph | Run | Tab | Table | TableCell | TableRow | Text;

interface HasChildren {
}

class Bookmark {
    readonly type: "Bookmark" = "Bookmark";
    readonly name: string;

    constructor(name: string) {
        this.name = name;
    }
}

class BreakLine {
    readonly type: "BreakLine" = "BreakLine";
}

class BreakPage {
    readonly type: "BreakPage" = "BreakPage";
}

class BreakColumn {
    readonly type: "BreakColumn" = "BreakColumn";
}

class Comment {
    readonly commentId: string;
    readonly body: ReadonlyArray<DocumentElement>;
    readonly authorName: string | null;
    readonly authorInitials: string | null;

    constructor(commentId: string, body: ReadonlyArray<DocumentElement>, authorName: string | null, authorInitials: string | null) {
        this.commentId = commentId;
        this.body = body;
        this.authorName = authorName;
        this.authorInitials = authorInitials;
    }
}

class CommentReference {
    readonly type: "CommentReference" = "CommentReference";
    readonly commentId: string;

    constructor(commentId: string) {
        this.commentId = commentId;
    }
}

class Document {
    readonly children: ReadonlyArray<DocumentElement>;
    readonly notes: ReadonlyArray<Note>;
    readonly comments: ReadonlyArray<Comment>;

    constructor(children: ReadonlyArray<DocumentElement>, notes: ReadonlyArray<Note>, comments: ReadonlyArray<Comment>) {
        this.children = children;
        this.notes = notes;
        this.comments = comments;
    }
}

class Hyperlink {
    readonly type: "Hyperlink" = "Hyperlink";
    readonly href: string;
    readonly targetFrame: string | null;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(href: string, targetFrame: string | null, children: ReadonlyArray<DocumentElement>) {
        this.href = href;
        this.targetFrame = targetFrame;
        this.children = children;
    }
}

class Image {
    readonly type: "Image" = "Image";
    readonly altText: string | null;
    readonly contentType: string | null;

    constructor(altText: string | null, contentType: string | null) {
        this.altText = altText;
        this.contentType = contentType;
    }
}

class Note {
    readonly noteType: NoteType;
    readonly id: string;
    readonly body: ReadonlyArray<DocumentElement>;

    constructor(noteType: NoteType, id: string, body: ReadonlyArray<DocumentElement>) {
        this.noteType = noteType;
        this.id = id;
        this.body = body;
    }
}

enum NoteType {
    FOOTNOTE,
    ENDNOTE,
}

class NoteReference {
    readonly type: "NoteReference" = "NoteReference";
    readonly noteType: NoteType;
    readonly noteId: string;

    constructor(noteType: NoteType, noteId: string) {
        this.noteType = noteType;
        this.noteId = noteId;
    }
}

class NumberingLevel {
    readonly levelIndex: string;
    readonly isOrdered: boolean;

    constructor(levelIndex: string, isOrdered: boolean) {
        this.levelIndex = levelIndex;
        this.isOrdered = isOrdered;
    }
}

class NumberingStyle {
    readonly numId: string;

    constructor(numId: string) {
        this.numId = numId;
    }
}

class Paragraph {
    readonly type: "Paragraph" = "Paragraph";
    readonly style: string | null;
    readonly numbering: NumberingLevel | null;
    readonly indent: ParagraphIndent;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(style: string | null, numbering: NumberingLevel | null, indent: ParagraphIndent, children: ReadonlyArray<DocumentElement>) {
        this.style = style;
        this.numbering = numbering;
        this.indent = indent;
        this.children = children;
    }
}

class ParagraphIndent {
    readonly start: string | null;
    readonly end: string | null;
    readonly firstLine: string | null;
    readonly hanging: string | null;

    constructor(start: string | null, end: string | null, firstLine: string | null, hanging: string | null) {
        this.start = start;
        this.end = end;
        this.firstLine = firstLine;
        this.hanging = hanging;
    }
}

class Run {
    readonly type: "Run" = "Run";
    readonly isBold: boolean;
    readonly isItalic: boolean;
    readonly isUnderline: boolean;
    readonly isStrikethrough: boolean;
    readonly isAllCaps: boolean;
    readonly isSmallCaps: boolean;
    readonly verticalAlignment: VerticalAlignment;
    readonly style: string | null;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(isBold: boolean, isItalic: boolean, isUnderline: boolean, isStrikethrough: boolean, isAllCaps: boolean, isSmallCaps: boolean, verticalAlignment: VerticalAlignment, style: string | null, children: ReadonlyArray<DocumentElement>) {
        this.isBold = isBold;
        this.isItalic = isItalic;
        this.isUnderline = isUnderline;
        this.isStrikethrough = isStrikethrough;
        this.isAllCaps = isAllCaps;
        this.isSmallCaps = isSmallCaps;
        this.verticalAlignment = verticalAlignment;
        this.style = style;
        this.children = children;
    }
}

class Style {
    readonly styleId: string;
    readonly name: string | null;

    constructor(styleId: string, name: string | null) {
        this.styleId = styleId;
        this.name = name;
    }
}

class Tab {
    readonly type: "Tab" = "Tab";
}

class Table {
    readonly type: "Table" = "Table";
    readonly style: Style | null;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(style: Style | null, children: ReadonlyArray<DocumentElement>) {
        this.style = style;
        this.children = children;
    }
}

class TableCell {
    readonly type: "TableCell" = "TableCell";
    readonly rowspan: number;
    readonly colspan: number;
    readonly children: ReadonlyArray<DocumentElement>;

    constructor(rowspan: number, colspan: number, children: ReadonlyArray<DocumentElement>) {
        this.rowspan = rowspan;
        this.colspan = colspan;
        this.children = children;
    }
}

class TableRow {
    readonly type: "TableRow" = "TableRow";
    readonly children: ReadonlyArray<DocumentElement>;
    readonly isHeader: boolean;

    constructor(children: ReadonlyArray<DocumentElement>, isHeader: boolean) {
        this.children = children;
        this.isHeader = isHeader;
    }
}

class Text {
    readonly type: "Text" = "Text";
    readonly value: string;

    constructor(value: string) {
        this.value = value;
    }
}

enum VerticalAlignment {
    SUPERSCRIPT,
    SUBSCRIPT,
    BASELINE,
}
export {Bookmark, BreakColumn, BreakLine, BreakPage, Comment, CommentReference, Document, DocumentElement, HasChildren, Hyperlink, Image, Note, NoteReference, NoteType, NumberingLevel, NumberingStyle, Paragraph, ParagraphIndent, Run, Style, Tab, Table, TableCell, TableRow, Text, VerticalAlignment};


==============

Output path: mammoth/xml.ts
type XmlNode = XmlElement | XmlTextNode;

interface XmlElementOrEmpty {
}

function element(name: string, attributes: Map<string, string>, children: ReadonlyArray<XmlNode>): XmlElement {
    return new XmlElement(name, attributes, children);
}

class XmlElement {
    readonly type: "XmlElement" = "XmlElement";
    readonly name: string;
    readonly attributes: Map<string, string>;
    readonly children: ReadonlyArray<XmlNode>;

    constructor(name: string, attributes: Map<string, string>, children: ReadonlyArray<XmlNode>) {
        this.name = name;
        this.attributes = attributes;
        this.children = children;
    }
    findChildren(name: string): XmlElementList {
        return new XmlElementList(this.children.flatMap((child) => child.type === "XmlElement" ? [child] : []).filter((child) => child.name === name));
    }

    findChildOrEmpty(name: string): XmlElementOrEmpty {
        for (let child of this.children) {
            if (child.type === "XmlElement") {
                if (child.name === name) {
                    return child;
                }
            }
        }

        return new XmlEmpty();
    }

    getAttribute(name: string): string | null {
        return this.attributes.get(name) ?? null;
    }
}

class XmlElementList {
    readonly elements: ReadonlyArray<XmlElement>;

    constructor(elements: ReadonlyArray<XmlElement>) {
        this.elements = elements;
    }
}

class XmlEmpty {
    findChildren(name: string): XmlElementList {
        return new XmlElementList([]);
    }

    getAttribute(name: string): string | null {
        return null;
    }
}


class XmlTextNode {
    readonly type: "XmlTextNode" = "XmlTextNode";
    readonly value: string;

    constructor(value: string) {
        this.value = value;
    }
}
export {XmlElement, XmlElementList, XmlElementOrEmpty, XmlEmpty, XmlNode, XmlTextNode, element};


==============

Output path: mammoth/docx/styles.ts
import {XmlElement} from "../xml";
import {XmlElementList} from "../xml";

// TODO: deal with naming conflict with namespace class Styles
class DocumentStyles {
    readonly paragraphStyles: Map<string, Style>;

    constructor(paragraphStyles: Map<string, Style>) {
        this.paragraphStyles = paragraphStyles;
    }
    findParagraphStyleById(name: string): Style | null {
        return null;
    }
}

class Style {
    readonly styleId: string;
    readonly name: string | null;

    constructor(styleId: string, name: string | null) {
        this.styleId = styleId;
        this.name = name;
    }
}

function readStylesXmlElement(element: XmlElement): DocumentStyles {
    let styleElements = element.findChildren("w:style");
    return new DocumentStyles(readStyles(styleElements, "paragraph"));
}

function readStyles(styleElements: XmlElementList, styleType: string): Map<string, Style> {
    return new Map([]);
}
export {DocumentStyles, Style, readStyles, readStylesXmlElement};


==============

Output path: mammoth/docx/styles.test.ts
import {equalTo} from "@mwilliamson/precisely";
import {assertThat} from "@mwilliamson/precisely";
import {deepEqualTo} from "@mwilliamson/precisely";
import {hasProperties} from "@mwilliamson/precisely";
import {readStylesXmlElement} from "./styles";
import {Style} from "./styles";
import * as xml from "../xml";

test("paragraph style is none if no style with that ID exists", function () {
    let element = xml.element("w:styles", new Map([]), []);

    let styles = readStylesXmlElement(element);

    assertThat(styles.findParagraphStyleById("Heading1"), equalTo(null));
});

test("paragraph style can be found by ID", function () {
    let element = xml.element("w:styles", new Map([]), [xml.element("w:style", new Map([["w:type", "paragraph"], ["w:styleId", "Heading1"]]), [xml.element("w:name", new Map([["w:val", "Heading 1"]]), [])])]);

    let styles = readStylesXmlElement(element);

    assertThat(styles.findParagraphStyleById("Heading1"), hasProperties({name: deepEqualTo("Heading 1")}));
});


==============

Output path: mammoth/html.ts
import {last as lodash_last} from "lodash";
import {isEqual as lodash_isEqual} from "lodash";
type HtmlNode = HtmlElement | HtmlForceWrite | HtmlText;

function element(tagNames: ReadonlyArray<string>, attributes: Map<string, string>, children: ReadonlyArray<HtmlNode>): HtmlElement {
    return freshElement(tagNames, attributes, children);
}

function collapsibleElement(tagNames: ReadonlyArray<string>, attributes: Map<string, string>, children: ReadonlyArray<HtmlNode>): HtmlElement {
    let tag = new HtmlTag(tagNames, attributes, true, "");
    return new HtmlElement(tag, children);
}

function freshElement(tagNames: ReadonlyArray<string>, attributes: Map<string, string>, children: ReadonlyArray<HtmlNode>): HtmlElement {
    let tag = new HtmlTag(tagNames, attributes, false, "");
    return new HtmlElement(tag, children);
}

function collapsibleElementWithSeparator(tagNames: ReadonlyArray<string>, attributes: Map<string, string>, children: ReadonlyArray<HtmlNode>, separator: string): HtmlElement {
    let tag = new HtmlTag(tagNames, attributes, true, separator);
    return new HtmlElement(tag, children);
}

function freshElementWithSeparator(tagNames: ReadonlyArray<string>, attributes: Map<string, string>, children: ReadonlyArray<HtmlNode>, separator: string): HtmlElement {
    let tag = new HtmlTag(tagNames, attributes, false, separator);
    return new HtmlElement(tag, children);
}

class HtmlElement {
    readonly type: "HtmlElement" = "HtmlElement";
    readonly tag: HtmlTag;
    readonly children: ReadonlyArray<HtmlNode>;

    constructor(tag: HtmlTag, children: ReadonlyArray<HtmlNode>) {
        this.tag = tag;
        this.children = children;
    }
    get attributes(): Map<string, string> {
        return this.tag.attributes;
    }

    get defaultTagName(): string {
        return this.tag.defaultTagName;
    }

    get tagNames(): ReadonlyArray<string> {
        return this.tag.tagNames;
    }

    get isCollapsible(): boolean {
        return this.tag.isCollapsible;
    }

    get isVoid(): boolean {
        return this.tag.isVoid;
    }

    get separator(): string {
        return this.tag.separator;
    }
}

function forceWrite(): HtmlForceWrite {
    // TODO: support top-level variables
    return new HtmlForceWrite();
}

class HtmlForceWrite {
    readonly type: "HtmlForceWrite" = "HtmlForceWrite";
}

class HtmlTag {
    readonly tagNames: ReadonlyArray<string>;
    readonly attributes: Map<string, string>;
    readonly isCollapsible: boolean;
    readonly separator: string;

    constructor(tagNames: ReadonlyArray<string>, attributes: Map<string, string>, isCollapsible: boolean, separator: string) {
        this.tagNames = tagNames;
        this.attributes = attributes;
        this.isCollapsible = isCollapsible;
        this.separator = separator;
    }
    get defaultTagName(): string {
        return this.tagNames[0];
    }

    get isVoid(): boolean {
        return this.defaultTagName === "br" || this.defaultTagName === "hr" || this.defaultTagName === "img";
    }
}

function text(value: string): HtmlText {
    return new HtmlText(value);
}

class HtmlText {
    readonly type: "HtmlText" = "HtmlText";
    readonly value: string;

    constructor(value: string) {
        this.value = value;
    }
    get isEmpty(): boolean {
        return this.value === "";
    }
}

function stripEmpty(nodes: ReadonlyArray<HtmlNode>): ReadonlyArray<HtmlNode> {
    return nodes.flatMap((node) => stripEmptyNode(node));
}

function stripEmptyNode(node: HtmlNode): ReadonlyArray<HtmlNode> {
    switch (node.type) {
        case "HtmlElement":
            let children = stripEmpty(node.children);
            if (!node.isVoid && children.length === 0) {
                return [];
            } else {
                return [new HtmlElement(node.tag, children)];
            }
        case "HtmlForceWrite":
            return [node];
        case "HtmlText":
            if (node.isEmpty) {
                return [];
            } else {
                return [node];
            }
    }
}

function collapse(nodes: ReadonlyArray<HtmlNode>): ReadonlyArray<HtmlNode> {
    let collapsed = new Array<HtmlNode>();

    for (let node of nodes) {
        collapsingAdd(collapsed, node);
    }

    return collapsed;
}

function collapsingAdd(collapsed: Array<HtmlNode>, node: HtmlNode): void {
    let collapsedNode = collapseNode(node);
    if (!tryCollapse(collapsed, collapsedNode)) {
        collapsed.push(collapsedNode);
    }
}

function collapseNode(node: HtmlNode): HtmlNode {
    switch (node.type) {
        case "HtmlElement":
            return new HtmlElement(node.tag, collapse(node.children));
        case "HtmlForceWrite":
            return node;
        case "HtmlText":
            return node;
    }
}

function tryCollapse(collapsed: Array<HtmlNode>, node: HtmlNode): boolean {
    if (collapsed.length === 0) {
        return false;
    }

    let last = lodash_last(collapsed)!;

    if (!(node.type === "HtmlElement")) {
        return false;
    }

    if (!(last.type === "HtmlElement")) {
        return false;
    }

    if (!node.isCollapsible || !(node.tagNames.includes(last.defaultTagName) && lodash_isEqual(node.attributes, last.attributes))) {
        return false;
    }

    if (node.separator !== "") {
        ((last.children) as Array<HtmlNode>).push(text(node.separator));
    }

    for (let child of node.children) {
        collapsingAdd(((last.children) as Array<HtmlNode>), child);
    }

    return true;
}
export {HtmlElement, HtmlForceWrite, HtmlNode, HtmlTag, HtmlText, collapse, collapseNode, collapsibleElement, collapsibleElementWithSeparator, collapsingAdd, element, forceWrite, freshElement, freshElementWithSeparator, stripEmpty, stripEmptyNode, text, tryCollapse};


==============

Output path: mammoth/html.test.ts
import {deepEqualTo} from "@mwilliamson/precisely";
import {assertThat} from "@mwilliamson/precisely";
import * as html from "./html";

suite("stripEmpty", function () {
    test("text nodes with text are not stripped", function () {
        let nodes = [html.text("H")];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.text("H")]));
    });

    test("empty text nodes are stripped", function () {
        let nodes = [html.text("")];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([]));
    });

    test("elements with non-empty children are not stripped", function () {
        let nodes = [html.element(["p"], new Map([]), [html.text("H")])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.element(["p"], new Map([]), [html.text("H")])]));
    });

    test("elements with no children are stripped", function () {
        let nodes = [html.element(["p"], new Map([]), [])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([]));
    });

    test("elements with only empty children are stripped", function () {
        let nodes = [html.element(["p"], new Map([]), [html.text("")])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([]));
    });

    test("empty children are removed", function () {
        let nodes = [html.element(["ul"], new Map([]), [html.element(["li"], new Map([]), [html.text("")]), html.element(["li"], new Map([]), [html.text("H")])])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.element(["ul"], new Map([]), [html.element(["li"], new Map([]), [html.text("H")])])]));
    });

    test("self-closing elements are never empty", function () {
        let nodes = [html.element(["br"], new Map([]), [])];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.element(["br"], new Map([]), [])]));
    });

    test("force writes are never empty", function () {
        let nodes = [html.forceWrite()];

        let result = html.stripEmpty(nodes);

        assertThat(result, deepEqualTo([html.forceWrite()]));
    });
});

suite("collapse", function () {
    test("collapsing does nothing to single text node", function () {
        let nodes = [html.text("Bluebells")];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.text("Bluebells")]));
    });

    test("consecutive fresh elements are not collapsed", function () {
        let nodes = [html.freshElement(["p"], new Map([]), []), html.freshElement(["p"], new Map([]), [])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.freshElement(["p"], new Map([]), []), html.freshElement(["p"], new Map([]), [])]));
    });

    test("elements with different tag names are not collapsed", function () {
        let nodes = [html.collapsibleElement(["p"], new Map([]), [html.text("One")]), html.collapsibleElement(["div"], new Map([]), [html.text("Two")])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.collapsibleElement(["p"], new Map([]), [html.text("One")]), html.collapsibleElement(["div"], new Map([]), [html.text("Two")])]));
    });

    test("elements with different attributes are not collapsed", function () {
        let nodes = [html.collapsibleElement(["p"], new Map([["id", "a"]]), [html.text("One")]), html.collapsibleElement(["p"], new Map([]), [html.text("Two")])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.collapsibleElement(["p"], new Map([["id", "a"]]), [html.text("One")]), html.collapsibleElement(["p"], new Map([]), [html.text("Two")])]));
    });

    test("consecutive collapsible elements are collapsed if they have the same tag name and no attributes", function () {
        let nodes = [html.collapsibleElement(["p"], new Map([]), [html.text("One")]), html.collapsibleElement(["p"], new Map([]), [html.text("Two")])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.collapsibleElement(["p"], new Map([]), [html.text("One"), html.text("Two")])]));
    });

    test("consecutive collapsible elements are collapsed if they have the same tag name and same attributes", function () {
        let nodes = [html.collapsibleElement(["p"], new Map([["a", "1"], ["b", "2"]]), [html.text("One")]), html.collapsibleElement(["p"], new Map([["b", "2"], ["a", "1"]]), [html.text("Two")])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.collapsibleElement(["p"], new Map([["a", "1"], ["b", "2"]]), [html.text("One"), html.text("Two")])]));
    });

    test("children of elements are collapsed", function () {
        let nodes = [html.freshElement(["div"], new Map([]), [html.collapsibleElement(["p"], new Map([]), [html.text("One")]), html.collapsibleElement(["p"], new Map([]), [html.text("Two")])])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.freshElement(["div"], new Map([]), [html.collapsibleElement(["p"], new Map([]), [html.text("One"), html.text("Two")])])]));
    });

    test("children of collapsed element can collapse with children of previous element", function () {
        let nodes = [html.collapsibleElement(["blockquote"], new Map([]), [html.collapsibleElement(["p"], new Map([]), [html.text("One")])]), html.collapsibleElement(["blockquote"], new Map([]), [html.collapsibleElement(["p"], new Map([]), [html.text("Two")])])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.collapsibleElement(["blockquote"], new Map([]), [html.collapsibleElement(["p"], new Map([]), [html.text("One"), html.text("Two")])])]));
    });

    test("collapsible element can collapse into previous fresh element", function () {
        let nodes = [html.freshElement(["p"], new Map([]), []), html.collapsibleElement(["p"], new Map([]), [])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.freshElement(["p"], new Map([]), [])]));
    });

    test("consecutive elements can collapse if second element has choice of tag names including main tag name of first element", function () {
        let nodes = [html.collapsibleElement(["ol"], new Map([]), []), html.collapsibleElement(["ul", "ol"], new Map([]), [])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.collapsibleElement(["ol"], new Map([]), [])]));
    });

    test("consecutive elements cannot collapse if second element has tag name as non-main tag name of first element", function () {
        let nodes = [html.collapsibleElement(["ul", "ol"], new Map([]), []), html.collapsibleElement(["ol"], new Map([]), [])];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.collapsibleElement(["ul", "ol"], new Map([]), []), html.collapsibleElement(["ol"], new Map([]), [])]));
    });

    test("when separator is present then separator is prepended to collapsed element", function () {
        let nodes = [html.freshElement(["pre"], new Map([]), [html.text("Hello")]), html.collapsibleElementWithSeparator(["pre"], new Map([]), [html.text(" the"), html.text("re")], "\n")];

        let result = html.collapse(nodes);

        assertThat(result, deepEqualTo([html.freshElement(["pre"], new Map([]), [html.text("Hello"), html.text("\n"), html.text(" the"), html.text("re")])]));
    });
});


==============



  ✔ paragraph style is none if no style with that ID exists
  1) paragraph style can be found by ID
  stripEmpty
    ✔ text nodes with text are not stripped
    ✔ empty text nodes are stripped
    ✔ elements with non-empty children are not stripped
    ✔ elements with no children are stripped
    ✔ elements with only empty children are stripped
    ✔ empty children are removed
    ✔ self-closing elements are never empty
    ✔ force writes are never empty

  collapse
    ✔ collapsing does nothing to single text node
    ✔ consecutive fresh elements are not collapsed
    ✔ elements with different tag names are not collapsed
    ✔ elements with different attributes are not collapsed
    ✔ consecutive collapsible elements are collapsed if they have the same tag name and no attributes
    ✔ consecutive collapsible elements are collapsed if they have the same tag name and same attributes
    ✔ children of elements are collapsed
    ✔ children of collapsed element can collapse with children of previous element
    ✔ collapsible element can collapse into previous fresh element
    ✔ consecutive elements can collapse if second element has choice of tag names including main tag name of first element
    ✔ consecutive elements cannot collapse if second element has tag name as non-main tag name of first element
    ✔ when separator is present then separator is prepended to collapsed element


  21 passing (TIME)
  1 failing

  1) paragraph style can be found by ID:
     TypeError: Cannot convert undefined or null to object
      at hasOwnProperty (<anonymous>)
      at Object.match (node_modules/@mwilliamson/precisely/lib/hasProperties.js:17:54)
      at assertThat (node_modules/@mwilliamson/precisely/lib/assertThat.js:10:28)
      at Context.<anonymous> (src/mammoth/docx/styles.test.ts:22:15)
      at processImmediate (node:internal/timers:466:21)


