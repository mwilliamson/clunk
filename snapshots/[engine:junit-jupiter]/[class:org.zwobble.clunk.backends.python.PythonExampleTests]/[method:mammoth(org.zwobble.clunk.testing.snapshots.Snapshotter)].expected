Source path: src/mammoth/documents.clunk
sealed interface DocumentElement {
}

record Bookmark(name: String) <: DocumentElement

record BreakLine() <: DocumentElement

record BreakPage() <: DocumentElement

record BreakColumn() <: DocumentElement

record Comment(
    commentId: String,
    body: List[DocumentElement],
    authorName: Option[String],
    authorInitials: Option[String],
)

record CommentReference(commentId: String) <: DocumentElement

record Document(
    children: List[DocumentElement],
    notes: List[Note],
    comments: List[Comment],
)

record Hyperlink(
    href: String,
    targetFrame: Option[String],
    children: List[DocumentElement],
) <: DocumentElement

record Image(
    altText: Option[String],
    contentType: Option[String],
) <: DocumentElement

record Note(
    noteType: NoteType,
    id: String,
    body: List[DocumentElement],
)

enum NoteType {
    FOOTNOTE,
    ENDNOTE,
}

record NoteReference(
    noteType: NoteType,
    noteId: String,
) <: DocumentElement

record NumberingLevel(
    levelIndex: String,
    isOrdered: Bool,
)

record NumberingStyle(
    numId: String,
)

record Paragraph(
    style: Option[String],
    numbering: Option[NumberingLevel],
    indent: ParagraphIndent,
    children: List[DocumentElement],
) <: DocumentElement

record ParagraphIndent(
    start: Option[String],
    end: Option[String],
    firstLine: Option[String],
    hanging: Option[String],
)

record Run(
    isBold: Bool,
    isItalic: Bool,
    isUnderline: Bool,
    isStrikethrough: Bool,
    isAllCaps: Bool,
    isSmallCaps: Bool,
    verticalAlignment: VerticalAlignment,
    style: Option[String],
    children: List[DocumentElement],
) <: DocumentElement

record Style(
    styleId: String,
    name: Option[String],
)

record Tab() <: DocumentElement

record Table(
    style: Option[Style],
    children: List[DocumentElement],
) <: DocumentElement

record TableCell(
    rowspan: Int,
    colspan: Int,
    children: List[DocumentElement],
) <: DocumentElement

record TableRow(
    children: List[DocumentElement],
    isHeader: Bool,
) <: DocumentElement

record Text(
    value: String,
) <: DocumentElement

enum VerticalAlignment {
    SUPERSCRIPT,
    SUBSCRIPT,
    BASELINE
}


==============

Source path: src/mammoth/html.clunk
sealed interface HtmlNode {
}

record HtmlAttribute(name: String, value: String)

fun element(tagName: String, attributes: List[HtmlAttribute], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag([tagName], attributes, false, "");
    return HtmlElement(tag, children);
}

record HtmlElement(tag: HtmlTag, children: List[HtmlNode]) <: HtmlNode {
    property defaultTagName: String {
        return tag.defaultTagName;
    }
}

record HtmlForceWrite() <: HtmlNode

record HtmlTag(
    tagNames: List[String],
    attributes: List[HtmlAttribute],
    isCollapsible: Bool,
    separator: String,
) {
    property defaultTagName: String {
        return tagNames[0];
    }

    property isVoid: Bool {
        return defaultTagName == "br" ||
            defaultTagName == "hr" ||
            defaultTagName == "img";
    }
}

fun text(value: String) -> HtmlText {
    return HtmlText(value);
}

record HtmlText(value: String) <: HtmlNode {
    property isEmpty: Bool {
        return value == "";
    }
}

fun stripEmpty(nodes: List[HtmlNode]) -> List[HtmlNode] {
    return nodes.flatMap(stripEmptyNode);
}

fun stripEmptyNode(node: HtmlNode) -> List[HtmlNode] {
    switch (node) {
        case HtmlElement element {
            var children = stripEmpty(element.children);
            if (children.length() == 0) {
                return [];
            } else {
                return [element];
            }
        }

        case HtmlForceWrite forceWrite {
            return [forceWrite];
        }

        case HtmlText text {
            if (text.isEmpty) {
                return [];
            } else {
                return [text];
            }
        }
    }
}


==============

Source path: src/mammoth/html.test.clunk
import stdlib/assertions.assertThat;
import stdlib/matchers.equalTo;
import mammoth/html;

test "text nodes with text are not stripped" {
    var nodes = [html.text("H")];

    var result = html.stripEmpty(nodes);

    assertThat(result, equalTo([html.text("H")]));
}

test "empty text nodes are stripped" {
    var nodes = [html.text("")];

    var result = html.stripEmpty(nodes);

    assertThat(result, equalTo([]));
}

test "elements with non-empty children are not stripped" {
    var nodes = [html.element("p", [], [html.text("H")])];

    var result = html.stripEmpty(nodes);

    assertThat(result, equalTo([html.element("p", [], [html.text("H")])]));
}

test "elements with no children are stripped" {
    var nodes = [html.element("p", [], [])];

    var result = html.stripEmpty(nodes);

    assertThat(result, equalTo([]));
}

test "elements with only empty children are stripped" {
    var nodes = [html.element("p", [], [html.text("")])];

    var result = html.stripEmpty(nodes);

    assertThat(result, equalTo([]));
}


==============

Output path: mammoth/documents.py
from __future__ import annotations

import dataclasses
import typing
import enum
class DocumentElement:
    pass

@dataclasses.dataclass(frozen=True)
class Bookmark:
    name: str
    def accept(self, visitor):
        return visitor.visit_bookmark(self)

@dataclasses.dataclass(frozen=True)
class BreakLine:
    def accept(self, visitor):
        return visitor.visit_break_line(self)

@dataclasses.dataclass(frozen=True)
class BreakPage:
    def accept(self, visitor):
        return visitor.visit_break_page(self)

@dataclasses.dataclass(frozen=True)
class BreakColumn:
    def accept(self, visitor):
        return visitor.visit_break_column(self)

@dataclasses.dataclass(frozen=True)
class Comment:
    comment_id: str
    body: typing.List[DocumentElement]
    author_name: typing.Optional[str]
    author_initials: typing.Optional[str]

@dataclasses.dataclass(frozen=True)
class CommentReference:
    comment_id: str
    def accept(self, visitor):
        return visitor.visit_comment_reference(self)

@dataclasses.dataclass(frozen=True)
class Document:
    children: typing.List[DocumentElement]
    notes: typing.List[Note]
    comments: typing.List[Comment]

@dataclasses.dataclass(frozen=True)
class Hyperlink:
    href: str
    target_frame: typing.Optional[str]
    children: typing.List[DocumentElement]
    def accept(self, visitor):
        return visitor.visit_hyperlink(self)

@dataclasses.dataclass(frozen=True)
class Image:
    alt_text: typing.Optional[str]
    content_type: typing.Optional[str]
    def accept(self, visitor):
        return visitor.visit_image(self)

@dataclasses.dataclass(frozen=True)
class Note:
    note_type: NoteType
    id: str
    body: typing.List[DocumentElement]

class NoteType(enum.Enum):
    FOOTNOTE = enum.auto()
    ENDNOTE = enum.auto()

@dataclasses.dataclass(frozen=True)
class NoteReference:
    note_type: NoteType
    note_id: str
    def accept(self, visitor):
        return visitor.visit_note_reference(self)

@dataclasses.dataclass(frozen=True)
class NumberingLevel:
    level_index: str
    is_ordered: bool

@dataclasses.dataclass(frozen=True)
class NumberingStyle:
    num_id: str

@dataclasses.dataclass(frozen=True)
class Paragraph:
    style: typing.Optional[str]
    numbering: typing.Optional[NumberingLevel]
    indent: ParagraphIndent
    children: typing.List[DocumentElement]
    def accept(self, visitor):
        return visitor.visit_paragraph(self)

@dataclasses.dataclass(frozen=True)
class ParagraphIndent:
    start: typing.Optional[str]
    end: typing.Optional[str]
    first_line: typing.Optional[str]
    hanging: typing.Optional[str]

@dataclasses.dataclass(frozen=True)
class Run:
    is_bold: bool
    is_italic: bool
    is_underline: bool
    is_strikethrough: bool
    is_all_caps: bool
    is_small_caps: bool
    vertical_alignment: VerticalAlignment
    style: typing.Optional[str]
    children: typing.List[DocumentElement]
    def accept(self, visitor):
        return visitor.visit_run(self)

@dataclasses.dataclass(frozen=True)
class Style:
    style_id: str
    name: typing.Optional[str]

@dataclasses.dataclass(frozen=True)
class Tab:
    def accept(self, visitor):
        return visitor.visit_tab(self)

@dataclasses.dataclass(frozen=True)
class Table:
    style: typing.Optional[Style]
    children: typing.List[DocumentElement]
    def accept(self, visitor):
        return visitor.visit_table(self)

@dataclasses.dataclass(frozen=True)
class TableCell:
    rowspan: int
    colspan: int
    children: typing.List[DocumentElement]
    def accept(self, visitor):
        return visitor.visit_table_cell(self)

@dataclasses.dataclass(frozen=True)
class TableRow:
    children: typing.List[DocumentElement]
    is_header: bool
    def accept(self, visitor):
        return visitor.visit_table_row(self)

@dataclasses.dataclass(frozen=True)
class Text:
    value: str
    def accept(self, visitor):
        return visitor.visit_text(self)

class VerticalAlignment(enum.Enum):
    SUPERSCRIPT = enum.auto()
    SUBSCRIPT = enum.auto()
    BASELINE = enum.auto()


==============

Output path: mammoth/html.py
from __future__ import annotations

import dataclasses
import typing
class HtmlNode:
    pass

@dataclasses.dataclass(frozen=True)
class HtmlAttribute:
    name: str
    value: str

def element(tag_name, attributes, children):
    tag = HtmlTag([tag_name], attributes, False, "")
    return HtmlElement(tag, children)

@dataclasses.dataclass(frozen=True)
class HtmlElement:
    tag: HtmlTag
    children: typing.List[HtmlNode]
    @property
    def default_tag_name(self):
        return self.tag.default_tag_name
    def accept(self, visitor):
        return visitor.visit_html_element(self)

@dataclasses.dataclass(frozen=True)
class HtmlForceWrite:
    def accept(self, visitor):
        return visitor.visit_html_force_write(self)

@dataclasses.dataclass(frozen=True)
class HtmlTag:
    tag_names: typing.List[str]
    attributes: typing.List[HtmlAttribute]
    is_collapsible: bool
    separator: str
    @property
    def default_tag_name(self):
        return self.tag_names[0]

    @property
    def is_void(self):
        return self.default_tag_name == "br" or self.default_tag_name == "hr" or self.default_tag_name == "img"

def text(value):
    return HtmlText(value)

@dataclasses.dataclass(frozen=True)
class HtmlText:
    value: str
    @property
    def is_empty(self):
        return self.value == ""
    def accept(self, visitor):
        return visitor.visit_html_text(self)

def strip_empty(nodes):
    return [_result for _element in nodes for _result in strip_empty_node(_element)]

def strip_empty_node(node):
    class Visitor:
        def visit_html_element(self, element):
            children = strip_empty(element.children)
            if len(children) == 0:
                return []
            else:
                return [element]
        def visit_html_force_write(self, force_write):
            return [force_write]
        def visit_html_text(self, text):
            if text.is_empty:
                return []
            else:
                return [text]
    return node.accept(Visitor())


==============

Output path: mammoth/html_test.py
from __future__ import annotations

from precisely import assert_that
from precisely import equal_to
from mammoth import html

def test_text_nodes_with_text_are_not_stripped():
    nodes = [html.text("H")]

    result = html.strip_empty(nodes)

    assert_that(result, equal_to([html.text("H")]))

def test_empty_text_nodes_are_stripped():
    nodes = [html.text("")]

    result = html.strip_empty(nodes)

    assert_that(result, equal_to([]))

def test_elements_with_non_empty_children_are_not_stripped():
    nodes = [html.element("p", [], [html.text("H")])]

    result = html.strip_empty(nodes)

    assert_that(result, equal_to([html.element("p", [], [html.text("H")])]))

def test_elements_with_no_children_are_stripped():
    nodes = [html.element("p", [], [])]

    result = html.strip_empty(nodes)

    assert_that(result, equal_to([]))

def test_elements_with_only_empty_children_are_stripped():
    nodes = [html.element("p", [], [html.text("")])]

    result = html.strip_empty(nodes)

    assert_that(result, equal_to([]))


==============

============================= test session starts ==============================
rootdir: ROOTDIR, configfile: tox.ini
collected 5 items

mammoth/html_test.py .....                                               [100%]

============================== 5 passed in TIME ===============================