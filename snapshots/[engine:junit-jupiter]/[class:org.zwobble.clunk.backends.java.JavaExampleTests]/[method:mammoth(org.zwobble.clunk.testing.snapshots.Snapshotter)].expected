Source path: src/mammoth/documents.clunk
sealed interface DocumentElement {
}

interface HasChildren {
}

record Bookmark(name: String) <: DocumentElement

record BreakLine() <: DocumentElement

record BreakPage() <: DocumentElement

record BreakColumn() <: DocumentElement

record Comment(
    commentId: String,
    body: List[DocumentElement],
    authorName: Option[String],
    authorInitials: Option[String],
)

record CommentReference(commentId: String) <: DocumentElement

record Document(
    children: List[DocumentElement],
    notes: List[Note],
    comments: List[Comment],
) <: HasChildren

record Hyperlink(
    href: String,
    targetFrame: Option[String],
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record Image(
    altText: Option[String],
    contentType: Option[String],
) <: DocumentElement

record Note(
    noteType: NoteType,
    id: String,
    body: List[DocumentElement],
)

enum NoteType {
    FOOTNOTE,
    ENDNOTE,
}

record NoteReference(
    noteType: NoteType,
    noteId: String,
) <: DocumentElement

record NumberingLevel(
    levelIndex: String,
    isOrdered: Bool,
)

record NumberingStyle(
    numId: String,
)

record Paragraph(
    style: Option[String],
    numbering: Option[NumberingLevel],
    indent: ParagraphIndent,
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record ParagraphIndent(
    start: Option[String],
    end: Option[String],
    firstLine: Option[String],
    hanging: Option[String],
)

record Run(
    isBold: Bool,
    isItalic: Bool,
    isUnderline: Bool,
    isStrikethrough: Bool,
    isAllCaps: Bool,
    isSmallCaps: Bool,
    verticalAlignment: VerticalAlignment,
    style: Option[String],
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record Style(
    styleId: String,
    name: Option[String],
)

record Tab() <: DocumentElement

record Table(
    style: Option[Style],
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record TableCell(
    rowspan: Int,
    colspan: Int,
    children: List[DocumentElement],
) <: DocumentElement, HasChildren

record TableRow(
    children: List[DocumentElement],
    isHeader: Bool,
) <: DocumentElement, HasChildren

record Text(
    value: String,
) <: DocumentElement

enum VerticalAlignment {
    SUPERSCRIPT,
    SUBSCRIPT,
    BASELINE
}


==============

Source path: src/mammoth/docx/styles.clunk
import mammoth/xml.XmlElement;
import mammoth/xml.XmlElementList;

// TODO: deal with naming conflict with namespace class Styles
record DocumentStyles(paragraphStyles: Map[String, Style]) {
    fun findParagraphStyleById(name: String) -> Option[Style] {
        return none();
    }
}

record Style(styleId: String, name: Option[String])

fun readStylesXmlElement(element: XmlElement) -> DocumentStyles {
    var styleElements = element.findChildren("w:style");
    return DocumentStyles(readStyles(styleElements, "paragraph"));
}

fun readStyles(styleElements: XmlElementList, styleType: String) -> Map[String, Style] {
    return #[];
}


==============

Source path: src/mammoth/docx/styles.test.clunk
import stdlib/assertions.assertThat;
import stdlib/matchers.equalTo;
import stdlib/matchers.hasMember;
import stdlib/matchers.isNone;
import stdlib/matchers.isSome;
import mammoth/docx/styles.readStylesXmlElement;
import mammoth/docx/styles.Style;
import mammoth/xml;

test "paragraph style is none if no style with that ID exists" {
    var element = xml.element("w:styles", #[], []);

    var styles = readStylesXmlElement(element);

    assertThat(styles.findParagraphStyleById("Heading1"), isNone());
}

test "paragraph style can be found by ID" {
    var element = xml.element("w:styles", #[], [
        xml.element("w:style", #[["w:type", "paragraph"], ["w:styleId", "Heading1"]], [
            xml.element("w:name", #[["w:val", "Heading 1"]], []),
        ]),
    ]);

    var styles = readStylesXmlElement(element);

    assertThat(
        styles.findParagraphStyleById("Heading1"),
        isSome(hasMember(Style::name, isSome(equalTo("Heading 1")))),
    );
}


==============

Source path: src/mammoth/html.clunk
sealed interface HtmlNode {
}

fun element(tagNames: List[String], attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    return freshElement(tagNames, attributes, children);
}

fun collapsibleElement(tagNames: List[String], attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, true, "");
    return HtmlElement(tag, children);
}

fun freshElement(tagNames: List[String], attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, false, "");
    return HtmlElement(tag, children);
}

fun collapsibleElementWithSeparator(
    tagNames: List[String],
    attributes: Map[String, String],
    children: List[HtmlNode],
    separator: String,
) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, true, separator);
    return HtmlElement(tag, children);
}

fun freshElementWithSeparator(
    tagNames: List[String],
    attributes: Map[String, String],
    children: List[HtmlNode],
    separator: String,
) -> HtmlElement {
    var tag = HtmlTag(tagNames, attributes, false, separator);
    return HtmlElement(tag, children);
}

record HtmlElement(tag: HtmlTag, children: List[HtmlNode]) <: HtmlNode {
    property attributes: Map[String, String] {
        return tag.attributes;
    }

    property defaultTagName: String {
        return tag.defaultTagName;
    }

    property tagNames: List[String] {
        return tag.tagNames;
    }

    property isCollapsible: Bool {
        return tag.isCollapsible;
    }

    property isVoid: Bool {
        return tag.isVoid;
    }

    property separator: String {
        return tag.separator;
    }
}

fun forceWrite() -> HtmlForceWrite {
    // TODO: support top-level variables
    return HtmlForceWrite();
}

record HtmlForceWrite() <: HtmlNode

record HtmlTag(
    tagNames: List[String],
    attributes: Map[String, String],
    isCollapsible: Bool,
    separator: String,
) {
    property defaultTagName: String {
        return tagNames.get(0);
    }

    property isVoid: Bool {
        return defaultTagName == "br" ||
            defaultTagName == "hr" ||
            defaultTagName == "img";
    }
}

fun text(value: String) -> HtmlText {
    return HtmlText(value);
}

record HtmlText(value: String) <: HtmlNode {
    property isEmpty: Bool {
        return value == "";
    }
}

fun stripEmpty(nodes: List[HtmlNode]) -> List[HtmlNode] {
    return [
        for node in nodes
        for child in stripEmptyNode(node)
        yield child
    ];
}

fun stripEmptyNode(node: HtmlNode) -> List[HtmlNode] {
    switch (node) {
        case HtmlElement {
            var children = stripEmpty(node.children);
            if (!node.isVoid && children.length() == 0) {
                return [];
            } else {
                return [HtmlElement(node.tag, children)];
            }
        }

        case HtmlForceWrite {
            return [node];
        }

        case HtmlText {
            if (node.isEmpty) {
                return [];
            } else {
                return [node];
            }
        }
    }
}

fun collapse(nodes: List[HtmlNode]) -> List[HtmlNode] {
    var collapsed = MutableList[HtmlNode]();

    for (var node in nodes) {
        collapsingAdd(collapsed, node);
    }

    return collapsed;
}

fun collapsingAdd(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Unit {
    var collapsedNode = collapseNode(node);
    if (!tryCollapse(collapsed, collapsedNode)) {
        collapsed.add(collapsedNode);
    }
}

fun collapseNode(node: HtmlNode) -> HtmlNode {
    switch (node) {
        case HtmlElement {
            return HtmlElement(
                node.tag,
                collapse(node.children),
            );
        }

        case HtmlForceWrite {
            return node;
        }

        case HtmlText {
            return node;
        }
    }
}

fun tryCollapse(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Bool {
    if (collapsed.length() == 0) {
        return false;
    }

    var last = collapsed.last();

    if (!(node instanceof HtmlElement)) {
        return false;
    }

    if (!(last instanceof HtmlElement)) {
        return false;
    }

    if (!node.isCollapsible || !(node.tagNames.contains(last.defaultTagName) && node.attributes == last.attributes)) {
        return false;
    }

    if (node.separator != "") {
        (last.children as MutableList[HtmlNode]).add(text(node.separator));
    }

    for (var child in node.children) {
        collapsingAdd(last.children as MutableList[HtmlNode], child);
    }

    return true;
}


==============

Source path: src/mammoth/html.test.clunk
import stdlib/assertions.assertThat;
import stdlib/matchers.equalTo;
import mammoth/html;

testSuite "stripEmpty" {
    test "text nodes with text are not stripped" {
        var nodes = [html.text("H")];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.text("H")]));
    }

    test "empty text nodes are stripped" {
        var nodes = [html.text("")];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "elements with non-empty children are not stripped" {
        var nodes = [html.element(["p"], #[], [html.text("H")])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.element(["p"], #[], [html.text("H")])]));
    }

    test "elements with no children are stripped" {
        var nodes = [html.element(["p"], #[], [])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "elements with only empty children are stripped" {
        var nodes = [html.element(["p"], #[], [html.text("")])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([]));
    }

    test "empty children are removed" {
        var nodes = [
            html.element(["ul"], #[], [
                html.element(["li"], #[], [html.text("")]),
                html.element(["li"], #[], [html.text("H")]),
            ]),
        ];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([
            html.element(["ul"], #[], [
                html.element(["li"], #[], [html.text("H")]),
            ]),
        ]));
    }

    test "self-closing elements are never empty" {
        var nodes = [html.element(["br"], #[], [])];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.element(["br"], #[], [])]));
    }

    test "force writes are never empty" {
        var nodes = [html.forceWrite()];

        var result = html.stripEmpty(nodes);

        assertThat(result, equalTo([html.forceWrite()]));
    }
}

testSuite "collapse" {
    test "collapsing does nothing to single text node" {
        var nodes = [html.text("Bluebells")];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([html.text("Bluebells")]));
    }

    test "consecutive fresh elements are not collapsed" {
        var nodes = [
            html.freshElement(["p"], #[], []),
            html.freshElement(["p"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["p"], #[], []),
            html.freshElement(["p"], #[], []),
        ]));
    }

    test "elements with different tag names are not collapsed" {
        var nodes = [
            html.collapsibleElement(["p"], #[], [html.text("One")]),
            html.collapsibleElement(["div"], #[], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[], [html.text("One")]),
            html.collapsibleElement(["div"], #[], [html.text("Two")]),
        ]));
    }

    test "elements with different attributes are not collapsed" {
        var nodes = [
            html.collapsibleElement(["p"], #[["id", "a"]], [html.text("One")]),
            html.collapsibleElement(["p"], #[], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[["id", "a"]], [html.text("One")]),
            html.collapsibleElement(["p"], #[], [html.text("Two")]),
        ]));
    }

    test "consecutive collapsible elements are collapsed if they have the same tag name and no attributes" {
        var nodes = [
            html.collapsibleElement(["p"], #[], [html.text("One")]),
            html.collapsibleElement(["p"], #[], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[], [html.text("One"), html.text("Two")]),
        ]));
    }

    test "consecutive collapsible elements are collapsed if they have the same tag name and same attributes" {
        var nodes = [
            html.collapsibleElement(["p"], #[["a", "1"], ["b", "2"]], [html.text("One")]),
            html.collapsibleElement(["p"], #[["b", "2"], ["a", "1"]], [html.text("Two")]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["p"], #[["a", "1"], ["b", "2"]], [html.text("One"), html.text("Two")]),
        ]));
    }

    test "children of elements are collapsed" {
        var nodes = [
            html.freshElement(["div"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One")]),
                html.collapsibleElement(["p"], #[], [html.text("Two")]),
            ]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["div"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One"), html.text("Two")]),
            ]),
        ]));
    }

    test "children of collapsed element can collapse with children of previous element" {
        var nodes = [
            html.collapsibleElement(["blockquote"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One")]),
            ]),
            html.collapsibleElement(["blockquote"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("Two")]),
            ]),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["blockquote"], #[], [
                html.collapsibleElement(["p"], #[], [html.text("One"), html.text("Two")]),
            ]),
        ]));
    }

    test "collapsible element can collapse into previous fresh element" {
        var nodes = [
            html.freshElement(["p"], #[], []),
            html.collapsibleElement(["p"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["p"], #[], []),
        ]));
    }

    test "consecutive elements can collapse if second element has choice of tag names including main tag name of first element" {
        var nodes = [
            html.collapsibleElement(["ol"], #[], []),
            html.collapsibleElement(["ul", "ol"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["ol"], #[], []),
        ]));
    }

    test "consecutive elements cannot collapse if second element has tag name as non-main tag name of first element" {
        var nodes = [
            html.collapsibleElement(["ul", "ol"], #[], []),
            html.collapsibleElement(["ol"], #[], []),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.collapsibleElement(["ul", "ol"], #[], []),
            html.collapsibleElement(["ol"], #[], []),
        ]));
    }

    test "when separator is present then separator is prepended to collapsed element" {
        var nodes = [
            html.freshElement(["pre"], #[], [html.text("Hello")]),
            html.collapsibleElementWithSeparator(
                ["pre"],
                #[],
                [html.text(" the"), html.text("re")],
                "\n"
            ),
        ];

        var result = html.collapse(nodes);

        assertThat(result, equalTo([
            html.freshElement(["pre"], #[], [
                html.text("Hello"),
                html.text("\n"),
                html.text(" the"),
                html.text("re"),
            ]),
        ]));
    }
}


==============

Source path: src/mammoth/xml.clunk
sealed interface XmlNode {
}

fun element(
    name: String,
    attributes: Map[String, String],
    children: List[XmlNode],
) -> XmlElement {
    return XmlElement(name, attributes, children);
}

record XmlElement(
    name: String,
    attributes: Map[String, String],
    children: List[XmlNode],
) <: XmlNode {
    fun findChildren(name: String) -> XmlElementList {
        return XmlElementList([
            for child in children
            if child instanceof XmlElement
            if child.name == name
            yield child
        ]);
    }

    fun getAttribute(name: String) -> Option[String] {
        return attributes.get(name);
    }
}

record XmlElementList(
    elements: List[XmlElement],
)

record XmlTextNode(
    value: String,
) <: XmlNode


==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/DocumentElement.java
package org.zwobble.mammoth.internal.mammoth.documents;

public sealed interface DocumentElement permits Bookmark, BreakLine, BreakPage, BreakColumn, CommentReference, Hyperlink, Image, NoteReference, Paragraph, Run, Tab, Table, TableCell, TableRow, Text {
    <T> T accept(Visitor<T> visitor);
    public interface Visitor<T> {
        T visit(Bookmark bookmark);
        T visit(BreakLine breakLine);
        T visit(BreakPage breakPage);
        T visit(BreakColumn breakColumn);
        T visit(CommentReference commentReference);
        T visit(Hyperlink hyperlink);
        T visit(Image image);
        T visit(NoteReference noteReference);
        T visit(Paragraph paragraph);
        T visit(Run run);
        T visit(Tab tab);
        T visit(Table table);
        T visit(TableCell tableCell);
        T visit(TableRow tableRow);
        T visit(Text text);
    }
}


==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/HasChildren.java
package org.zwobble.mammoth.internal.mammoth.documents;

public interface HasChildren {
}


==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Bookmark.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Bookmark(String name) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/BreakLine.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record BreakLine() implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/BreakPage.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record BreakPage() implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/BreakColumn.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record BreakColumn() implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Comment.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Comment(String commentId, java.util.List<? extends DocumentElement> body, java.util.Optional<String> authorName, java.util.Optional<String> authorInitials) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/CommentReference.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record CommentReference(String commentId) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Document.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Document(java.util.List<? extends DocumentElement> children, java.util.List<Note> notes, java.util.List<Comment> comments) implements org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Hyperlink.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Hyperlink(String href, java.util.Optional<String> targetFrame, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Image.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Image(java.util.Optional<String> altText, java.util.Optional<String> contentType) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Note.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Note(NoteType noteType, String id, java.util.List<? extends DocumentElement> body) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/NoteType.java
package org.zwobble.mammoth.internal.mammoth.documents;

public enum NoteType {
    FOOTNOTE,
    ENDNOTE
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/NoteReference.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record NoteReference(NoteType noteType, String noteId) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/NumberingLevel.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record NumberingLevel(String levelIndex, boolean isOrdered) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/NumberingStyle.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record NumberingStyle(String numId) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Paragraph.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Paragraph(java.util.Optional<String> style, java.util.Optional<NumberingLevel> numbering, ParagraphIndent indent, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/ParagraphIndent.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record ParagraphIndent(java.util.Optional<String> start, java.util.Optional<String> end, java.util.Optional<String> firstLine, java.util.Optional<String> hanging) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Run.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Run(boolean isBold, boolean isItalic, boolean isUnderline, boolean isStrikethrough, boolean isAllCaps, boolean isSmallCaps, VerticalAlignment verticalAlignment, java.util.Optional<String> style, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Style.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Style(String styleId, java.util.Optional<String> name) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Tab.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Tab() implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Table.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Table(java.util.Optional<Style> style, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/TableCell.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record TableCell(int rowspan, int colspan, java.util.List<? extends DocumentElement> children) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/TableRow.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record TableRow(java.util.List<? extends DocumentElement> children, boolean isHeader) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement, org.zwobble.mammoth.internal.mammoth.documents.HasChildren {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/Text.java
package org.zwobble.mammoth.internal.mammoth.documents;

public record Text(String value) implements org.zwobble.mammoth.internal.mammoth.documents.DocumentElement {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.documents.DocumentElement.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/documents/VerticalAlignment.java
package org.zwobble.mammoth.internal.mammoth.documents;

public enum VerticalAlignment {
    SUPERSCRIPT,
    SUBSCRIPT,
    BASELINE
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/XmlNode.java
package org.zwobble.mammoth.internal.mammoth.xml;

public sealed interface XmlNode permits XmlElement, XmlTextNode {
    <T> T accept(Visitor<T> visitor);
    public interface Visitor<T> {
        T visit(XmlElement xmlElement);
        T visit(XmlTextNode xmlTextNode);
    }
}


==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/XmlElement.java
package org.zwobble.mammoth.internal.mammoth.xml;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElementList;

public record XmlElement(String name, java.util.Map<String, String> attributes, java.util.List<? extends XmlNode> children) implements org.zwobble.mammoth.internal.mammoth.xml.XmlNode {
    public XmlElementList findChildren(String name) {
        return new XmlElementList(children().stream().flatMap((child) -> child instanceof XmlElement ? java.util.stream.Stream.of((org.zwobble.mammoth.internal.mammoth.xml.XmlElement) child) : null).filter((child) -> child.name().equals(name)).toList());
    }

    public java.util.Optional<String> getAttribute(String name) {
        return java.util.Optional.ofNullable(attributes().get(name));
    }
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.xml.XmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/XmlElementList.java
package org.zwobble.mammoth.internal.mammoth.xml;

public record XmlElementList(java.util.List<XmlElement> elements) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/XmlTextNode.java
package org.zwobble.mammoth.internal.mammoth.xml;

public record XmlTextNode(String value) implements org.zwobble.mammoth.internal.mammoth.xml.XmlNode {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.xml.XmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/xml/Xml.java
package org.zwobble.mammoth.internal.mammoth.xml;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElement;

public class Xml {
    public static XmlElement element(String name, java.util.Map<String, String> attributes, java.util.List<? extends XmlNode> children) {
        return new XmlElement(name, attributes, children);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/docx/styles/DocumentStyles.java
package org.zwobble.mammoth.internal.mammoth.docx.styles;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElement;
import org.zwobble.mammoth.internal.mammoth.xml.XmlElementList;
import java.util.Optional;

public record DocumentStyles(java.util.Map<String, Style> paragraphStyles) {
    public java.util.Optional<Style> findParagraphStyleById(String name) {
        return Optional.empty();
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/docx/styles/Style.java
package org.zwobble.mammoth.internal.mammoth.docx.styles;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElement;
import org.zwobble.mammoth.internal.mammoth.xml.XmlElementList;

public record Style(String styleId, java.util.Optional<String> name) {
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/docx/styles/Styles.java
package org.zwobble.mammoth.internal.mammoth.docx.styles;

import org.zwobble.mammoth.internal.mammoth.xml.XmlElement;
import org.zwobble.mammoth.internal.mammoth.xml.XmlElementList;
import org.zwobble.mammoth.internal.mammoth.docx.styles.DocumentStyles;

public class Styles {
    public static DocumentStyles readStylesXmlElement(XmlElement element) {
        var styleElements = element.findChildren("w:style");
        return new DocumentStyles(readStyles(styleElements, "paragraph"));
    }
    public static java.util.Map<String, Style> readStyles(XmlElementList styleElements, String styleType) {
        return java.util.Map.ofEntries();
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/docx/styles/StylesTests.java
package org.zwobble.mammoth.internal.mammoth.docx.styles;

import static org.zwobble.mammoth.internal.mammoth.docx.styles.Styles.readStylesXmlElement;
import org.zwobble.mammoth.internal.mammoth.docx.styles.Style;
import org.zwobble.mammoth.internal.mammoth.xml.Xml;
import static org.zwobble.precisely.Matchers.equalTo;
import java.util.Optional;
import static org.zwobble.precisely.AssertThat.assertThat;
import static org.zwobble.precisely.Matchers.isOptionalOf;
import static org.zwobble.precisely.Matchers.has;

public class StylesTests {
    @org.junit.jupiter.api.Test
    @org.junit.jupiter.api.DisplayName("paragraph style is none if no style with that ID exists")
    public void paragraphStyleIsNoneIfNoStyleWithThatIDExists() {
        var element = Xml.element("w:styles", java.util.Map.ofEntries(), java.util.List.of());

        var styles = readStylesXmlElement(element);

        assertThat(styles.findParagraphStyleById("Heading1"), equalTo(Optional.empty()));
    }
    @org.junit.jupiter.api.Test
    @org.junit.jupiter.api.DisplayName("paragraph style can be found by ID")
    public void paragraphStyleCanBeFoundByID() {
        var element = Xml.element("w:styles", java.util.Map.ofEntries(), java.util.List.of(Xml.element("w:style", java.util.Map.ofEntries(java.util.Map.entry("w:type", "paragraph"), java.util.Map.entry("w:styleId", "Heading1")), java.util.List.of(Xml.element("w:name", java.util.Map.ofEntries(java.util.Map.entry("w:val", "Heading 1")), java.util.List.of())))));

        var styles = readStylesXmlElement(element);

        assertThat(styles.findParagraphStyleById("Heading1"), isOptionalOf(has("name", org.zwobble.mammoth.internal.mammoth.docx.styles.Style::name, isOptionalOf(equalTo("Heading 1")))));
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlNode.java
package org.zwobble.mammoth.internal.mammoth.html;

public sealed interface HtmlNode permits HtmlElement, HtmlForceWrite, HtmlText {
    <T> T accept(Visitor<T> visitor);
    public interface Visitor<T> {
        T visit(HtmlElement htmlElement);
        T visit(HtmlForceWrite htmlForceWrite);
        T visit(HtmlText htmlText);
    }
}


==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlElement.java
package org.zwobble.mammoth.internal.mammoth.html;

public record HtmlElement(HtmlTag tag, java.util.List<? extends HtmlNode> children) implements org.zwobble.mammoth.internal.mammoth.html.HtmlNode {
    public java.util.Map<String, String> attributes() {
        return tag().attributes();
    }

    public String defaultTagName() {
        return tag().defaultTagName();
    }

    public java.util.List<String> tagNames() {
        return tag().tagNames();
    }

    public boolean isCollapsible() {
        return tag().isCollapsible();
    }

    public boolean isVoid() {
        return tag().isVoid();
    }

    public String separator() {
        return tag().separator();
    }
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.html.HtmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlForceWrite.java
package org.zwobble.mammoth.internal.mammoth.html;

public record HtmlForceWrite() implements org.zwobble.mammoth.internal.mammoth.html.HtmlNode {
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.html.HtmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlTag.java
package org.zwobble.mammoth.internal.mammoth.html;

public record HtmlTag(java.util.List<String> tagNames, java.util.Map<String, String> attributes, boolean isCollapsible, String separator) {
    public String defaultTagName() {
        return tagNames().get(0);
    }

    public boolean isVoid() {
        return defaultTagName().equals("br") || defaultTagName().equals("hr") || defaultTagName().equals("img");
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlText.java
package org.zwobble.mammoth.internal.mammoth.html;

public record HtmlText(String value) implements org.zwobble.mammoth.internal.mammoth.html.HtmlNode {
    public boolean isEmpty() {
        return value().equals("");
    }
    public <T> T accept(org.zwobble.mammoth.internal.mammoth.html.HtmlNode.Visitor<T> visitor) {
        return visitor.visit(this);
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/Html.java
package org.zwobble.mammoth.internal.mammoth.html;

import org.zwobble.mammoth.internal.mammoth.html.HtmlTag;
import org.zwobble.mammoth.internal.mammoth.html.HtmlElement;
import org.zwobble.mammoth.internal.mammoth.html.HtmlForceWrite;
import org.zwobble.mammoth.internal.mammoth.html.HtmlText;
import org.zwobble.mammoth.internal.mammoth.html.HtmlNode;

public class Html {
    public static HtmlElement element(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children) {
        return freshElement(tagNames, attributes, children);
    }
    public static HtmlElement collapsibleElement(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children) {
        var tag = new HtmlTag(tagNames, attributes, true, "");
        return new HtmlElement(tag, children);
    }
    public static HtmlElement freshElement(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children) {
        var tag = new HtmlTag(tagNames, attributes, false, "");
        return new HtmlElement(tag, children);
    }
    public static HtmlElement collapsibleElementWithSeparator(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children, String separator) {
        var tag = new HtmlTag(tagNames, attributes, true, separator);
        return new HtmlElement(tag, children);
    }
    public static HtmlElement freshElementWithSeparator(java.util.List<String> tagNames, java.util.Map<String, String> attributes, java.util.List<? extends HtmlNode> children, String separator) {
        var tag = new HtmlTag(tagNames, attributes, false, separator);
        return new HtmlElement(tag, children);
    }
    public static HtmlForceWrite forceWrite() {
        // TODO: support top-level variables
        return new HtmlForceWrite();
    }
    public static HtmlText text(String value) {
        return new HtmlText(value);
    }
    public static java.util.List<? extends HtmlNode> stripEmpty(java.util.List<? extends HtmlNode> nodes) {
        return nodes.stream().flatMap((node) -> stripEmptyNode(node).stream()).toList();
    }
    public static java.util.List<? extends HtmlNode> stripEmptyNode(HtmlNode node) {
        return node.accept(new HtmlNode.Visitor<>() {
            @Override
            public java.util.List<org.zwobble.mammoth.internal.mammoth.html.HtmlNode> visit(HtmlElement node) {
                var children = stripEmpty(node.children());
                if (!node.isVoid() && children.size() == 0) {
                    return java.util.List.of();
                } else {
                    return java.util.List.of(new HtmlElement(node.tag(), children));
                }
            }
            @Override
            public java.util.List<org.zwobble.mammoth.internal.mammoth.html.HtmlNode> visit(HtmlForceWrite node) {
                return java.util.List.of(node);
            }
            @Override
            public java.util.List<org.zwobble.mammoth.internal.mammoth.html.HtmlNode> visit(HtmlText node) {
                if (node.isEmpty()) {
                    return java.util.List.of();
                } else {
                    return java.util.List.of(node);
                }
            }
        });
    }
    public static java.util.List<? extends HtmlNode> collapse(java.util.List<? extends HtmlNode> nodes) {
        var collapsed = new java.util.ArrayList<org.zwobble.mammoth.internal.mammoth.html.HtmlNode>();

        for (var node : nodes) {
            collapsingAdd(collapsed, node);
        }

        return collapsed;
    }
    public static void collapsingAdd(java.util.List<HtmlNode> collapsed, HtmlNode node) {
        var collapsedNode = collapseNode(node);
        if (!tryCollapse(collapsed, collapsedNode)) {
            collapsed.add(collapsedNode);
        }
    }
    public static HtmlNode collapseNode(HtmlNode node) {
        return node.accept(new HtmlNode.Visitor<>() {
            @Override
            public org.zwobble.mammoth.internal.mammoth.html.HtmlNode visit(HtmlElement node) {
                return new HtmlElement(node.tag(), collapse(node.children()));
            }
            @Override
            public org.zwobble.mammoth.internal.mammoth.html.HtmlNode visit(HtmlForceWrite node) {
                return node;
            }
            @Override
            public org.zwobble.mammoth.internal.mammoth.html.HtmlNode visit(HtmlText node) {
                return node;
            }
        });
    }
    public static boolean tryCollapse(java.util.List<HtmlNode> collapsed, HtmlNode node) {
        if (collapsed.size() == 0) {
            return false;
        }

        var last = collapsed.get(collapsed.size() - 1);

        if (!(node instanceof HtmlElement)) {
            return false;
        }
        var node_HtmlElement = (org.zwobble.mammoth.internal.mammoth.html.HtmlElement) node;

        if (!(last instanceof HtmlElement)) {
            return false;
        }
        var last_HtmlElement = (org.zwobble.mammoth.internal.mammoth.html.HtmlElement) last;

        if (!node_HtmlElement.isCollapsible() || !(node_HtmlElement.tagNames().contains(last_HtmlElement.defaultTagName()) && node_HtmlElement.attributes().equals(last_HtmlElement.attributes()))) {
            return false;
        }

        if (!node_HtmlElement.separator().equals("")) {
            ((java.util.List<HtmlNode>) last_HtmlElement.children()).add(text(node_HtmlElement.separator()));
        }

        for (var child : node_HtmlElement.children()) {
            collapsingAdd((java.util.List<HtmlNode>) last_HtmlElement.children(), child);
        }

        return true;
    }
}

==============

Output path: org/zwobble/mammoth/internal/mammoth/html/HtmlTests.java
package org.zwobble.mammoth.internal.mammoth.html;

import org.zwobble.mammoth.internal.mammoth.html.Html;
import static org.zwobble.precisely.Matchers.equalTo;
import static org.zwobble.precisely.AssertThat.assertThat;

public class HtmlTests {
    @org.junit.jupiter.api.Nested
    public class StripEmpty {
        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("text nodes with text are not stripped")
        public void textNodesWithTextAreNotStripped() {
            var nodes = java.util.List.of(Html.text("H"));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.text("H"))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("empty text nodes are stripped")
        public void emptyTextNodesAreStripped() {
            var nodes = java.util.List.of(Html.text(""));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of()));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with non-empty children are not stripped")
        public void elementsWithNonEmptyChildrenAreNotStripped() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("H"))));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.element(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("H"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with no children are stripped")
        public void elementsWithNoChildrenAreStripped() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of()));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with only empty children are stripped")
        public void elementsWithOnlyEmptyChildrenAreStripped() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text(""))));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of()));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("empty children are removed")
        public void emptyChildrenAreRemoved() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("ul"), java.util.Map.ofEntries(), java.util.List.of(Html.element(java.util.List.of("li"), java.util.Map.ofEntries(), java.util.List.of(Html.text(""))), Html.element(java.util.List.of("li"), java.util.Map.ofEntries(), java.util.List.of(Html.text("H"))))));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.element(java.util.List.of("ul"), java.util.Map.ofEntries(), java.util.List.of(Html.element(java.util.List.of("li"), java.util.Map.ofEntries(), java.util.List.of(Html.text("H"))))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("self-closing elements are never empty")
        public void selfClosingElementsAreNeverEmpty() {
            var nodes = java.util.List.of(Html.element(java.util.List.of("br"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.element(java.util.List.of("br"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("force writes are never empty")
        public void forceWritesAreNeverEmpty() {
            var nodes = java.util.List.of(Html.forceWrite());

            var result = Html.stripEmpty(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.forceWrite())));
        }
    }@org.junit.jupiter.api.Nested
    public class Collapse {
        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("collapsing does nothing to single text node")
        public void collapsingDoesNothingToSingleTextNode() {
            var nodes = java.util.List.of(Html.text("Bluebells"));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.text("Bluebells"))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive fresh elements are not collapsed")
        public void consecutiveFreshElementsAreNotCollapsed() {
            var nodes = java.util.List.of(Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()), Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()), Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with different tag names are not collapsed")
        public void elementsWithDifferentTagNamesAreNotCollapsed() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("div"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("div"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("elements with different attributes are not collapsed")
        public void elementsWithDifferentAttributesAreNotCollapsed() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("id", "a")), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("id", "a")), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive collapsible elements are collapsed if they have the same tag name and no attributes")
        public void consecutiveCollapsibleElementsAreCollapsedIfTheyHaveTheSameTagNameAndNoAttributes() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"), Html.text("Two"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive collapsible elements are collapsed if they have the same tag name and same attributes")
        public void consecutiveCollapsibleElementsAreCollapsedIfTheyHaveTheSameTagNameAndSameAttributes() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("a", "1"), java.util.Map.entry("b", "2")), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("b", "2"), java.util.Map.entry("a", "1")), java.util.List.of(Html.text("Two"))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(java.util.Map.entry("a", "1"), java.util.Map.entry("b", "2")), java.util.List.of(Html.text("One"), Html.text("Two"))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("children of elements are collapsed")
        public void childrenOfElementsAreCollapsed() {
            var nodes = java.util.List.of(Html.freshElement(java.util.List.of("div"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.freshElement(java.util.List.of("div"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"), Html.text("Two"))))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("children of collapsed element can collapse with children of previous element")
        public void childrenOfCollapsedElementCanCollapseWithChildrenOfPreviousElement() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("blockquote"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"))))), Html.collapsibleElement(java.util.List.of("blockquote"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Two"))))));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("blockquote"), java.util.Map.ofEntries(), java.util.List.of(Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of(Html.text("One"), Html.text("Two"))))))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("collapsible element can collapse into previous fresh element")
        public void collapsibleElementCanCollapseIntoPreviousFreshElement() {
            var nodes = java.util.List.of(Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()), Html.collapsibleElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.freshElement(java.util.List.of("p"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive elements can collapse if second element has choice of tag names including main tag name of first element")
        public void consecutiveElementsCanCollapseIfSecondElementHasChoiceOfTagNamesIncludingMainTagNameOfFirstElement() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("ol"), java.util.Map.ofEntries(), java.util.List.of()), Html.collapsibleElement(java.util.List.of("ul", "ol"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("ol"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("consecutive elements cannot collapse if second element has tag name as non-main tag name of first element")
        public void consecutiveElementsCannotCollapseIfSecondElementHasTagNameAsNonMainTagNameOfFirstElement() {
            var nodes = java.util.List.of(Html.collapsibleElement(java.util.List.of("ul", "ol"), java.util.Map.ofEntries(), java.util.List.of()), Html.collapsibleElement(java.util.List.of("ol"), java.util.Map.ofEntries(), java.util.List.of()));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.collapsibleElement(java.util.List.of("ul", "ol"), java.util.Map.ofEntries(), java.util.List.of()), Html.collapsibleElement(java.util.List.of("ol"), java.util.Map.ofEntries(), java.util.List.of()))));
        }

        @org.junit.jupiter.api.Test
        @org.junit.jupiter.api.DisplayName("when separator is present then separator is prepended to collapsed element")
        public void whenSeparatorIsPresentThenSeparatorIsPrependedToCollapsedElement() {
            var nodes = java.util.List.of(Html.freshElement(java.util.List.of("pre"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Hello"))), Html.collapsibleElementWithSeparator(java.util.List.of("pre"), java.util.Map.ofEntries(), java.util.List.of(Html.text(" the"), Html.text("re")), "\n"));

            var result = Html.collapse(nodes);

            assertThat(result, equalTo(java.util.List.of(Html.freshElement(java.util.List.of("pre"), java.util.Map.ofEntries(), java.util.List.of(Html.text("Hello"), Html.text("\n"), Html.text(" the"), Html.text("re"))))));
        }
    }}

==============


 JUnit Jupiter 
   StylesTests 
     paragraph style can be found by ID  
            Expected:
              optional value:
                name:
                  optional value:
                    "Heading 1"
            but:
              was empty
     paragraph style is none if no style with that ID exists 
   HtmlTests 
      Collapse 
        consecutive elements can collapse if second element has choice of tag names incl... 
        elements with different attributes are not collapsed 
        when separator is present then separator is prepended to collapsed element 
        collapsing does nothing to single text node 
        collapsible element can collapse into previous fresh element 
        consecutive fresh elements are not collapsed 
        elements with different tag names are not collapsed 
        consecutive collapsible elements are collapsed if they have the same tag name an... 
        children of elements are collapsed 
        consecutive collapsible elements are collapsed if they have the same tag name an... 
        consecutive elements cannot collapse if second element has tag name as non-main ... 
        children of collapsed element can collapse with children of previous element 
      StripEmpty 
         text nodes with text are not stripped 
         force writes are never empty 
         elements with no children are stripped 
         empty text nodes are stripped 
         self-closing elements are never empty 
         empty children are removed 
         elements with non-empty children are not stripped 
         elements with only empty children are stripped 
 JUnit Vintage 

Failures (1):
  JUnit Jupiter:StylesTests:paragraph style can be found by ID
    MethodSource [className = 'org.zwobble.mammoth.internal.mammoth.docx.styles.StylesTests', methodName = 'paragraphStyleCanBeFoundByID', methodParameterTypes = '']
    => java.lang.AssertionError: 
Expected:
  optional value:
    name:
      optional value:
        "Heading 1"
but:
  was empty
       org.zwobble.precisely.AssertThat.assertThat(AssertThat.java:15)
       org.zwobble.mammoth.internal.mammoth.docx.styles.StylesTests.paragraphStyleCanBeFoundByID(Unknown Source)
       java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
       java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
       java.base/java.lang.reflect.Method.invoke(Method.java:568)
       org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)
       org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
       org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
       org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
       [...]

Test run finished after TIME ms
[         6 containers found      ]
[         0 containers skipped    ]
[         6 containers started    ]
[         0 containers aborted    ]
[         6 containers successful ]
[         0 containers failed     ]
[        22 tests found           ]
[         0 tests skipped         ]
[        22 tests started         ]
[         0 tests aborted         ]
[        21 tests successful      ]
[         1 tests failed          ]
