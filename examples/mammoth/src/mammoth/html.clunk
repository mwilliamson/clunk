sealed interface HtmlNode {
}

fun element(tagName: String, attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    return freshElement(tagName, attributes, children);
}

fun collapsibleElement(tagName: String, attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag([tagName], attributes, true, "");
    return HtmlElement(tag, children);
}

fun freshElement(tagName: String, attributes: Map[String, String], children: List[HtmlNode]) -> HtmlElement {
    var tag = HtmlTag([tagName], attributes, false, "");
    return HtmlElement(tag, children);
}

record HtmlElement(tag: HtmlTag, children: List[HtmlNode]) <: HtmlNode {
    property attributes: Map[String, String] {
        return tag.attributes;
    }

    property defaultTagName: String {
        return tag.defaultTagName;
    }

    property tagNames: List[String] {
        return tag.tagNames;
    }

    property isCollapsible: Bool {
        return tag.isCollapsible;
    }

    property isVoid: Bool {
        return tag.isVoid;
    }

    property separator: String {
        return tag.separator;
    }
}

record HtmlTagBuilder(tagName: String, isCollapsible: Bool, separator: String) {
    fun collapsible() -> HtmlTagBuilder {
        return HtmlTagBuilder(tagName, true, separator);
    }

    fun fresh() -> HtmlTagBuilder {
        return HtmlTagBuilder(tagName, false, separator);
    }

    fun withSeparator(newSeparator: String) -> HtmlTagBuilder {
        return HtmlTagBuilder(tagName, isCollapsible, newSeparator);
    }

    fun element(children: List[HtmlNode]) -> HtmlElement {
        return HtmlElement(tag(), children);
    }

    fun tag() -> HtmlTag {
        return HtmlTag([tagName], #[], isCollapsible, separator);
    }
}

fun tagBuilder(tagName: String) -> HtmlTagBuilder {
    return HtmlTagBuilder(tagName, false, "");
}

fun forceWrite() -> HtmlForceWrite {
    // TODO: support top-level variables
    return HtmlForceWrite();
}

record HtmlForceWrite() <: HtmlNode

record HtmlTag(
    tagNames: List[String],
    attributes: Map[String, String],
    isCollapsible: Bool,
    separator: String,
) {
    property defaultTagName: String {
        return tagNames.get(0);
    }

    property isVoid: Bool {
        return defaultTagName == "br" ||
            defaultTagName == "hr" ||
            defaultTagName == "img";
    }
}

fun text(value: String) -> HtmlText {
    return HtmlText(value);
}

record HtmlText(value: String) <: HtmlNode {
    property isEmpty: Bool {
        return value == "";
    }
}

fun stripEmpty(nodes: List[HtmlNode]) -> List[HtmlNode] {
    return nodes.flatMap[HtmlNode](stripEmptyNode);
}

fun stripEmptyNode(node: HtmlNode) -> List[HtmlNode] {
    switch (node) {
        case HtmlElement {
            var children = stripEmpty(node.children);
            if (!node.isVoid && children.length() == 0) {
                return [];
            } else {
                return [HtmlElement(node.tag, children)];
            }
        }

        case HtmlForceWrite {
            return [node];
        }

        case HtmlText {
            if (node.isEmpty) {
                return [];
            } else {
                return [node];
            }
        }
    }
}

fun collapse(nodes: List[HtmlNode]) -> List[HtmlNode] {
    var collapsed = MutableList[HtmlNode]();

    for (var node in nodes) {
        collapsingAdd(collapsed, node);
    }

    return collapsed;
}

fun collapsingAdd(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Unit {
    var collapsedNode = collapseNode(node);
    if (!tryCollapse(collapsed, collapsedNode)) {
        collapsed.add(collapsedNode);
    }
}

fun collapseNode(node: HtmlNode) -> HtmlNode {
    switch (node) {
        case HtmlElement {
            return HtmlElement(
                node.tag,
                collapse(node.children),
            );
        }

        case HtmlForceWrite {
            return node;
        }

        case HtmlText {
            return node;
        }
    }
}

fun tryCollapse(collapsed: MutableList[HtmlNode], node: HtmlNode) -> Bool {
    if (collapsed.length() == 0) {
        return false;
    }

    var last = collapsed.last();

    if (!(node instanceof HtmlElement)) {
        return false;
    }

    if (!(last instanceof HtmlElement)) {
        return false;
    }

    if (!node.isCollapsible || !(node.tagNames.contains(last.defaultTagName) && node.attributes == last.attributes)) {
        return false;
    }

    if (node.separator != "") {
        (last.children as MutableList[HtmlNode]).add(text(node.separator));
    }

    for (var child in node.children) {
        collapsingAdd(last.children as MutableList[HtmlNode], child);
    }

    return true;
}
